[{"title":"性能指标","path":"/2024/02/06/性能指标/","content":"基于用户的性能指标FCP：白屏时间 FCP 时长 颜色编码 FCP 分数(HTTP 存档百分位数) 0-2s 快速 75-100 2-4s 中等 50-74 &gt;4s 慢 0-49 LCP：主要内容可见时间(可视区域最大-资源较大 元素到屏幕上的间隔时间) 并不是只初始加载页面的，而是指页面元素变化的时候 LCP 考虑的元素 &lt;img&gt;元素 &lt;image&gt;元素的&lt;svg&gt; &lt;video&gt; 通过[url()](https://developer.mozilla.org/en-US/docs/Web/CSS/url())函数加载背景图片的元素 包含文本节点或者其他内联文字元素子级的块级元素 LCP 时长 颜色编码 0-2.5s 快速 2.5-4s 中等 &gt;4s 慢 FID：首次输入延迟第一次与页面交互(点击按钮链接等)到浏览器实际能够响应这次交互的时间 输入延迟是因为浏览器的主线程处于繁忙状态(比如忙于解析和执行程序加载的大量计算的 js)，导致无法及时响应用户。 第一次的输入延迟通常发生在 FCP 和 TTI 之间，因为页面虽然已经呈现了，但是还无法可靠交互 FID 时长 颜色编码 0-0.1s 快速 0.1-0.3s 中等 &gt;0.3s 慢 TTI：第一次完全达到可交互状态浏览器可以持续性的响应用户的交互事件。完全达到可交互的状态时间点是在最后一个长文物(50ms 以上才能完成的任务)完成的事件，并且在随后的 5s 内网络和主线程是空闲的 TTI 时长 颜色编码 0-3.8s 快速 3.8-7.3s 中等 &gt;7.3s 慢 TBT：总阻塞时间即 FCP 和 TTI 之间的间隔时长，在改时间范围内，主线程被阻塞足够长的时间以防止用户的输入事件。 长任务，执行时长超过了 50ms 页面总阻塞时间&#x3D;FCP 和 TTI 之间发生的每个长任务的阻塞时间总和 长任务的阻塞时间&#x3D;长任务的实际执行时长-50ms TBT 时长 颜色编码 0-0.3s 快速 0.3-0.6s 中等 &gt;0.6s 慢 CLS：累计布局偏移在整个生命周期中发生的每个意外的布局移位(即在不是预计的位置偏移或者样式错乱)的所有单独布局。 保证页面的视觉稳定性 元素的意外移动通常是由于异步加载资源或者 DOM 元素动态添加到现有内容商法的页面而发生的 可能是由于尺寸未知的多媒体资源，字体变化或者动态调整自身大小的第三方广告、小部件 TBT 时长 颜色编码 0-0.1ms 快速 0.1-0.25ms 中等 &gt;0.25ms 慢 速度指数(SI)：页面可视区域中内容的填充速度计算页面可见区域内容显示的平均时间来衡量 捕获浏览器加载页面过程的视频，然后对每 100ms 间隔的页面截图计算页面内容的填充百分比 TBT 时长 颜色编码 0-4.3s 快速 4.3-5.8ms 中等 &gt;5.8ms 慢 RAIL 性能模型 RAIL R(响应)：应该尽可能快速的响应用户，应该在 100ms 内相应用户 A(Animation)：在展示动画的时候，每一帧应该以 16ms 进行渲染，这样可以保持动画的一致性，避免卡顿 I(空闲)：当使用 JS 主线程的时候，应该把任务划分到执行时间小于 50ms 的片段中，这样可以释放线程以进行用户交互 L(加载)：应该在小于 1s 的时间内完成加载网页，且可以进行用户交互 感知延迟的时间窗口 延迟时长 用户反映 0-16ms 人眼可以感知每秒 60 帧的动画，即每帧 16ms，除了浏览器将一帧画面绘制到屏幕上的时间，网站应用大约需要 10ms 生成一帧 0-100ms 在该范围内相应用户的操作，属于流畅的体验 100-1000ms 能够感知明显延迟 &gt;1s 用户注意力将离开对执行任务的关注 &gt;10s 感到过于长以至于失望，可能回放弃任务 Web VitalsCore Web Vitals应用于所有 web 页面的 Web Vitals 子集，为其最重要的核心 主要指标 LCP：加载性能 FID：交互性 CLS：视觉稳定性 测试工具 LightHouse WebPageTest DevTools","categories":["额外内容"]},{"title":"从地址栏到页面展示的流程","path":"/2024/02/06/输入url到页面展示/","content":"浏览器进程 1、UI 线程会判断输入的内容是搜索关键词还是 URL 如果是搜索关键词，跳转至默认搜索引擎对应都搜索 URL， 如果输入的内容是 URL，则开始请求 URL。 2、UI 线程将关键词搜索对应的 URL 或输入的 URL 交给网络线程 UI 线程使 Tab 前的图标展示为加载中状态 3、网络线程发出请求，获取请求返回内容 先查询是否有url是ip还是域名，如果是域名，先去进行查看是否有对应的ip解析缓存，没有就进行DNS查询 建立三次握手（AKC，seq这些） 发送请求 服务器返回请求 如果收到服务器的 301 重定向响应，它就会告知 UI 线程进行重定向然后它会再次发起一个新的网络请求。 根据响应头中的 Content-Type 字段来确定响应主体的媒体类型 如果媒体类型是一个HTML文件，则将响应数据交给渲染进程 如果是zip 文件或者其它文件，会把相关数据传输给存储线程，下载管理器。 浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，网络线程会展示一个警告页。除此之外，网络线程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程 四次挥手 4、网络线程确信浏览器可以导航到请求网页，网络线程会通知 UI 线程数据已经准备好，UI 线程会查找到一个 渲染进程进行网页的渲染。 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以在第二步开始，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当 network thread 接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。 5、浏览器进程 会向 渲染进程 发送 IPC 消息(进程通信的一种方式)来确认导航 浏览器进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送 IPC 消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。 6、当导航提交完成后，渲染进程开始加载资源及渲染页面，当页面渲染完成后（页面及内部的 iframe 都触发了 onload 事件），会向浏览器进程发送 IPC 消息，告知浏览器进程，这个时候 UI thread 会停止展示 tab 中的加载中图标。 渲染进程-关键渲染路径(CRP) 当渲染进程接受到导航的确认信息后，开始接受来自浏览器进程的数据，主线程会解析数据转化为 DOM 对象。 解析到图片、CSS、JavaScript 脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建 DOM 过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序。“预加载扫描器”是并发运行的，如果如果 HTML 中存在 img、link 等标签，预加载扫描程序会把这些请求传递给浏览器进程的网络线程进行资源下载。 找到一个&lt; script &gt;标签时，它会暂停 HTML 文档的解析，并且必须加载、解析和执行 JavaScript 代码。因为 JS 可以使用document.write()改变整个 DOM 结构之类的东西来改变文档的形状（ HTML 规范中的解析模型概述有一个很好的图表）。这就是 HTML 解析器必须等待 JavaScript 运行才能继续解析 HTML 文档的原因。V8 关于 JS 执行中的事情 因此如果 js 没有document.write()，可以添加 async 或 defer 属性到&lt; script &gt;标签。然后浏览器异步加载和运行 JavaScript 代码，这样不会阻止解析 DOM 主线程依据 Css 选择器以及浏览器默认样式来计算每个元素应该具备的具体样式 主线程会遍历 DOM 及相关元素的计算样式，构建出包含每个元素的页面坐标信息及盒子模型大小的布局树（Render Tree），遍历过程中，会跳过隐藏的元素（display: none），另外，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。 遍历布局树（layout tree），生成一系列的绘画记录（paint records）。绘画记录可以看做是记录各元素绘制先后顺序的笔记-绘画顺序表。 主线程需要遍历渲染树来创建一棵层次树（Layer Tree），对于添加了 will-change CSS 属性的元素，会被看做单独的一层，没有 will-change CSS 属性的元素，浏览器会根据情况决定是否要把该元素放在单独的层。 当页面的层超过一定的数量后，层的合成操作要比在每个帧中光栅化页面的一小部分还要慢，因此衡量你应用的渲染性能是十分重要的一件事情。 主线程会把这些信息通知给合成器线程，合成器线程开始对层次数的每一层进行光栅化。 为了优化显示体验，合成线程可以给不同的光栅线程赋予不同的优先级，将那些在视口中的或者视口附近的层先被光栅化。 有的层的可以达到整个页面的大小，合成器需要将它们切分为一块又一块的小图块（tiles） 合成器将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化 结束后光栅线程会将每个图块的光栅结果存在 GPU Process 的内存中 合成线程会收集图块上面叫做绘画四边形（draw quads）的信息来构建一个合成帧（compositor frame）。 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。 合成帧：代表页面一个帧的内容的绘制四边形集合。 合成线程就会通过 IPC 向浏览器进程（browser process）提交（commit）一个渲染帧。 这个时候可能有另外一个合成帧被浏览器进程的 UI 线程（UI thread）提交以改变浏览器的 UI。这些合成帧都会被发送给 GPU 从而展示在屏幕上。 如果合成线程收到页面滚动的事件，合成线程会构建另外一个组合帧发送给 GPU 来更新页面。 事件处理 当点击或者输入的时候，首先接受到事件的是浏览器进程 浏览器进程不处理，将事件丢给渲染进程 渲染进程依据事件发生的坐标，找到目标对象，运行附加的事件侦听器来适当地处理事件。 合成器线程会标记页面中绑定有事件处理器的区域为非快速滚动区域(non-fast scrollable region) 当合成器线程向主线程发送输入事件时，首先要运行的是命中测试以找到事件目标。命中测试使用渲染过程中生成的绘制记录数据来找出发生事件的点坐标下方的内容。 如果事件发生在这些存在标注的区域，合成器线程会把事件信息发送给主线程，等待主线程进行事件处理 如果事件不是发生在这些区域，合成器线程则会直接合成新的帧而不用等到主线程的响应。 所以，在进行事件监听的时候，尤其是事件捕获或者对整个文档进行事件监听的时候需要考虑一下，因为整个页面都被标记为非快速滚动区域。这意味着即使不关心来自页面某些部分的输入，合成器线程也必须与主线程通信并在每次输入事件进入时等待它。因此，合成器的平滑滚动能力被打败了。 12// 浏览器在主线程中侦听事件，但合成器也可以继续合成新帧。document.body.addEventListener(enent, func, &#123; passive: true &#125;); 参考链接合成器线程详解&#x2705; 一文搞懂浏览器的工作原理&#x270B; chrome 渲染器进程的内部工作原理&#x270B;","categories":["浏览器"]},{"title":"手写题","path":"/2024/02/06/手写题/","content":"将一维数组转化为 tree12345678910const list = [ &#123; id: &quot;01&quot;, parentId: 0, name: &quot;节点1&quot; &#125;, &#123; id: &quot;011&quot;, parentId: &quot;01&quot;, name: &quot;节点1-1&quot; &#125;, &#123; id: &quot;0111&quot;, parentId: &quot;011&quot;, name: &quot;节点1-1-1&quot; &#125;, &#123; id: &quot;02&quot;, parentId: 0, name: &quot;节点2&quot; &#125;, &#123; id: &quot;022&quot;, parentId: &quot;02&quot;, name: &quot;节点2-2&quot; &#125;, &#123; id: &quot;023&quot;, parentId: &quot;02&quot;, name: &quot;节点2-3&quot; &#125;, &#123; id: &quot;0222&quot;, parentId: &quot;022&quot;, name: &quot;节点2-2-2&quot; &#125;, &#123; id: &quot;03&quot;, parentId: 0, name: &quot;节点3&quot; &#125;,]; 解法 1： 使用循环+递归的形式 12345678910111213141516171819202122232425262728293031function findParent(tree, child) &#123; for (const cur of tree) &#123; if ( cur.id !== child.parentId &amp;&amp; cur.children &amp;&amp; cur.children.length !== 0 ) &#123; cur = findParent(cur.children, child); &#125; else if (cur.id === child.parentId) &#123; if (cur.children) &#123; cur.children.push(child); &#125; else &#123; cur.children = [child]; &#125; return tree; &#125; &#125; return tree;&#125;function arrToTree(arr) &#123; let tree = []; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (arr[i].parentId === 0) &#123; tree.push(arr[i]); &#125; else &#123; tree = findParent(tree, arr[i]); &#125; &#125; return tree;&#125; 解法 2： 使用 map 映射和 js 当引用类型赋值时，是拷贝的地址的特性 1234567891011121314function con(arr) &#123; const res = []; const map = arr.reduce((res, v) =&gt; ((res[v.id] = v), res), &#123;&#125;); for (const item of arr) &#123; if (item.parentId in map) &#123; const parent = map[item.parentId]; parent.children = parent.children || []; parent.children.push(item); &#125; else &#123; res.push(item); &#125; &#125; return res;&#125; object 键扁平化原始数据： 1234567891011121314151617181920&#123; &quot;a&quot;: &#123; &quot;b&quot;: &#123; &quot;c&quot;: 2 &#125;, &quot;d&quot;: 3 &#125;, &quot;d&quot;: &quot;d&quot;, &quot;e&quot;: &#123; &quot;f&quot;: &#123; &quot;g&quot;: &quot;g&quot;, &quot;f&quot;: &#123; &quot;h&quot;: &#123; &quot;i&quot;: &quot;i&quot; &#125; &#125; &#125;, &quot;g&quot;: &quot;g2&quot; &#125;&#125; 转换数据： 12345678&#123; &quot;a.b.c&quot;: 2, &quot;a.d&quot;: 3, &quot;d&quot;: &quot;d&quot;, &quot;e.f.g&quot;: &quot;g&quot;, &quot;e.f.f.h.i&quot;: &quot;i&quot;, &quot;e.g&quot;: &quot;g2&quot;&#125; 解法 1采用 dfs 思维做 123456789101112131415161718192021222324252627282930313233343536function dfs(tree, preKey = &quot;&quot;) &#123; if (typeof tree !== &quot;object&quot;) &#123; return &#123; key: preKey, value: tree, &#125;; &#125; const keys = Reflect.ownKeys(tree); let res = []; for (const key of keys) &#123; let val = dfs(tree[key], preKey + &quot;.&quot; + key); if (Array.isArray(val)) &#123; res = res.concat(val); &#125; else &#123; res.push(val); &#125; &#125; return res;&#125;function ObjectKeyToStr(obj) &#123; const keys = Reflect.ownKeys(obj); let res = &#123;&#125;; for (const key of keys) &#123; const data = dfs(obj[key], key); if (Array.isArray(data)) &#123; data.forEach((ele) =&gt; &#123; res[ele.key] = ele.value; &#125;); &#125; else &#123; res[data.key] = data.value; &#125; &#125; console.log(res); return res;&#125; 解法 2 采用类bfs的思路 123456789101112131415161718192021222324252627282930function getKeys(tree) &#123; return Reflect.ownKeys(tree);&#125;function bfs(tree) &#123; let stack = []; let res = &#123;&#125;; let item = tree; while (item) &#123; getKeys(item).forEach((ele) =&gt; &#123; const currdata = item[ele]; // 因为额外加了_key属性，因此需要跳过这个属性 if (ele !== &quot;_key&quot;) &#123; if (Object.prototype.toString.call(currdata) === &quot;[object Object]&quot;) &#123; stack.unshift(&#123; ...currdata, _key: item._key ? item._key + &quot;.&quot; + ele : ele, &#125;); &#125; else &#123; const key = item._key ? item._key + &quot;.&quot; + ele : ele; delete currdata._key; res[key] = currdata; &#125; &#125; &#125;); item = stack.shift(); &#125; console.log(res); return res;&#125;","categories":["js"]},{"title":"大数据渲染","path":"/2024/02/06/大数据渲染/","content":"大数据渲染table 分页 每页展示固定的数据 定时更新,分批渲染用requestAnimationFrame或者定时器, 加上DocumentFragment进行每次数据的加载 12345678910window.requestAnimationFrame(() =&gt; &#123; const fragment = new DocumentFragment(); const fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;, &quot;Melon&quot;]; fruits.forEach((fruit) =&gt; &#123; const ele = document.createElement(&quot;p&quot;); ele.textContent = fruit; fragment.appendChild(ele); &#125;); document.body.appendChild(fragment);&#125;); requestAnimationFrame是在style/layout/paint之前触发 使用虚拟列表IntersectionObserver123456789101112// 新建一个监听对象let io = new IntersectionObserver( (entris) =&gt; &#123; console.log(&quot;IntersectionObserver&quot;, entris); &#125;, &#123; root: null, thresholds: 1, &#125;);// 开始监听io.observe(document.getElementById(&quot;b&quot;)); 当元素初次在页面上显示, 以及之后每次显示和隐藏都会触发回调 IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。","categories":["业务场景"]},{"title":"v-model 和 reactive 组合使用的问题","path":"/2024/02/06/v-model和reactive组合使用的问题/","content":"问题描述概述父组件的数据是一个reactive的数据，传入子组件时用v-model:xxx的形式传入子组件，那么子组件在此情况下调用update:xxx时，并不会引起父组件的数据变化(包含页面和通过watch等方式去监听的回调) 演示 父组件代码 1&lt;test v-model:data=&quot;testdata&quot; /&gt; 12345678910const testdata = reactive(&#123; name: &quot;父级参数&quot;,&#125;);watch( () =&gt; testdata, (val) =&gt; &#123; console.log(&quot;父级变化了11111&quot;, val); &#125;, &#123; deep: true &#125;); 子组件代码 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;input :value=&quot;test.name&quot; @input=&quot;onIpt&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;reactive, watchEffect&#125; from &quot;vue&quot;const props = defineProps([&#x27;data&#x27;])const emit = defineEmits([&#x27;update:data&#x27;])const test = reactive(&#123; name: &quot;123&quot;&#125;)const onIpt = e =&gt; &#123; test.name = e.target.value console.log(&quot;子组件更新&quot;, test) emit(&quot;update:data&quot;, test)&#125;watchEffect(() =&gt; &#123; console.log(&quot;子组件接收到的父组件数据更新&quot;, test) test.name = props.data.name;&#125;)&lt;/script&gt; 实际操作 在进行输入的时候，只触发了onIpt函数，父组件的watch和子组件的watchEffect都未触发 原因在vue的官方文档上面写明的reactive的局限性： 有限的值类型 它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。 不能替换整个对象 由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失 对解构操作不友好 当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接 上面第二条说明了reactive的响应式是依据 属性访问 实现的，而update:data的时候是传递的整个对象，所以并不会引起reactive的响应式。 解决方案父组件的数据改为refref是针对整体的一个响应式，因此就不会产生这个问题 利用js引用对象的特性，修改prop的属性1234567const onIpt = e =&gt; &#123; const data = props.data; data.name = e.target.value console.log(&quot;子组件更新&quot;, data) // 实际是否加上update的函数，父组件的watch都会触发 // emit(&quot;update:data&quot;, test)&#125; 但是这样不符合单向数据流的特性，因此这个方法不合适 父组件监听事件1&lt;test v-model:data=&quot;testdata&quot; @update:data=&quot;onUpdateData&quot;/&gt; 123const onUpdateData = (data) =&gt; &#123; console.log(&quot;父组件事件的回调&quot;, data)&#125; 这样在子组件调用update:data的方法时，也会触发父组件的onUpdateData方法","categories":["vue"]},{"title":"v-html渲染自定义组件","path":"/2024/02/06/v-html渲染自定义组件/","content":"v-html渲染自定义组件前景 需求场景 后端返回的特定的元素，前端用穿梭框显示，拿到对应的元素后，将其替换为vant组件进行渲染。 坑点： v-html是vue3用于渲染html的指令，但是由于是直接渲染html的，自定义组件vue不会默认重新转化渲染。因此需要进行处理 方案使用vue自带的compile函数进行进行渲染转换，再用h函数进行显示 将v-html所用到的组件设置为全局组件 1234import &#123; Lazyload, SwipeItem, Swipe &#125; from &quot;vant&quot;;const app = createApp(App);app.component(&#x27;Swipe&#x27;, Swipe)app.component(&#x27;swipeitem&#x27;, SwipeItem) 新建一个用于渲染的组件 1234567891011121314 &lt;script lang=&quot;ts&quot;&gt; import &#123; h,&#125; from &#x27;vue&#x27;; // 如果直接从vue引入会报warning，因此引入路径需要修改 import &#123;compile&#125; from &quot;vue/dist/vue.esm-bundler.js&quot; export default &#123; props: &#123; html: &#123; type: String, required: true &#125; &#125;, setup(props)&#123; return () =&gt; h(compile(props.html)) &#125; &#125;&lt;/script&gt; 优缺点 优点 自定义组件也可以进行渲染 缺点 需要将用到的组件设置为全局组件，那么这样会使初始包变大 无法响应事件。组件标签上的事件无法执行，会有warning；事件只能在内部实现，无法暴露出去 参考link记录一下vue3 渲染带组件html字符串的方法","categories":["vue"]},{"title":"npm、npx与pnpm","path":"/2024/02/06/npm、npx与pnpm/","content":"npm、npx 与 pnpmnpmnpm i与npm update npm i：先检查 node_modules 模块是否有对应的指定模块，如果存在，就不再进行安装，即使远程有新版本也不会重新获取 npm i在安装包的依赖包时，包的依赖包会安装符合规则的最高版本 npm 都要强制重新安装，可以使用-f 或–force 参数。 npm update：每次安装都会先请求远程仓库的最新版本，然后查询本地版本。 如果本地版本不存在或者远程版本较新，那么更新版本 安装非发布的包官网表明了如下几个情况可以直接使用 a:包含一个由 package.json 文件描述的程序的文件夹。 b:包含（a）的 gzipped tarball 。 c:解析为（b）的 URL。 d:&lt;name&gt;@&lt;version&gt;: 在 registry 上发布的(c) e:&lt;name&gt;@&lt;tag&gt; : 能指向（d）。 f:&lt;name&gt; 具有 latest 标签，且满足（e）。 g:git url，当 clone 时，得到（a） 1234git://github.com/user/project.git#commit-ishgit+ssh://user@hostname:project.git#commit-ishgit+http://user@hostname/project/blah.git#commit-ishgit+https://user@hostname/project/blah.git#commit-ish commit-ish 可以是任何 tag、分支或者 sha，可以用git checkout切换的，默认是master npm 缓存由于安装时，即使本地有缓存，但是也不会进行读取，那么这就导致在弱网或者无网情况下，无法安装依赖包或者安装速度极低 --cache-min：参数指定了一个时间(以分钟为单位)，只有超过这个时间的模块，才会从远程进行下载安装 1npm install --cache-min 9999999 &lt;package-name&gt; npm i流程 发出npm i命令 执行工程自身 preinstall 如果当前工程定义了 preintsall 钩子，那么会调用这个钩子函数 确定首层依赖 确定当前项目中package.json中的dependencies和devDependencies指定的模块 当前项目中的每个依赖包是每个依赖树的根节点，所以 npm 开启多线程对每个依赖包进行更深层级的节点 获取模块 确定下载的模块版本 如果版本描述文件（npm-shrinkwrap.json 或 package-lock. json）有对应模块的信息，那么直接依据对应的信息获取 如果没有，向registry查询模块压缩 包的网址，然后依据package.json文件中的版本去仓库中获取。 获取到模块的 resloved 字段，即压缩包的地址后。获取到后，npm 依据此地址检查本地缓存，如果缓存中有，那么直接从缓存中(只会检查node_modules目录，而不会检查~/.npm目录)拿；如果没有，那么从仓库中进行下载 查找该模块的依赖，如果有依赖则回到第一步，没有则停止 扁平化模块 获取到完整的依赖树后，里面可能包含大量的重复模块，npm3 之前会严格按照依赖树的结构进行安装，这样会造成大量的模块冗余； npm3 之后默认加入了一个dedupe的过程，遍历所有节点，将模块放在根节点下面（node_modules 下），当发现有了重复模块时，将其丢弃 重复模块：模块名相同且semver兼容。每个 semver 基本都对应一段版本允许范围，如果两个模块的版本允许范围有交集，那么可以得到一个兼容版本。这样就不需要版本号完全一致了，减少更多的冗余模块在这个阶段中直接去掉 比如 A 模块依赖 package@^1.0.0，B 模块依赖 package@^1.1.0，则 1.1.0 为兼容版本 node_modules–A node_modules–B node_modules--package@^1.1.0 比如 A 模块依赖 package@^1.0.0，B 模块依赖 package@^2.1.0，则没有兼容版本，会将一个版本放在 node_modules，一个继续保留在依赖树中 node_modules--A--package@^1.0.0 node_modules--B--package@^1.1.0 安装模块 下载压缩包，存放在~&#x2F;.npm 目录 解压到当前项目的 node_modules 目录 执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。 执行当前项目自身的生命周期 当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。 生成或者更新版本描述文件（npm-shrinkwrap.json 或 package-lock. json） npxnpx是npm@5.25.2增加的命令，如果 npm 版本低于这个版本，那么用npm i -g npx安装即可 与 npm 的不同 npx 是下载到一个临时目录中，然后使用完成之后，进行删除。没有 npm 一样的缓存 npx 还可以运行可执行文件(远程的也可以)，比如只安装 webpack 了，那么用npm run webpack会报错，用npx run webpack就可以成功运行 npx 会检查 node_modules 和系统变量$PATH的命令是否存在 --no-install: 如果本地不存在该模块，那么会报错。可以用于强制使用本地模块 --ignore-existing: 不管是否本地存在，都强制安装使用远程模块。可以用于获取最新的包，即用即删 pnpm硬连接与符号连接 硬连接：使用 inode 指向源文件，即使源文件目录地址变化了，但是依旧能进行访问。因为其 inode 仍指向该文件。没有对原始文件的引用。 符号连接：指向的源文件地址，如果源文件目的地址修改了，那么就无法再访问；如果有一个新的文件名字与源文件一致，那么再次访问时，访问的是新文件 pnpm缓存pnpm 和 npm 一样，有一个缓存目录 Mac&#x2F;linux 中默认会设置到{home dir}&gt;&#x2F;.pnpm-store&#x2F;v3；windows 下会设置到当前盘的根目录下，比如 C（C&#x2F;.pnpm-store&#x2F;v3）、D 盘（D&#x2F;.pnpm-store&#x2F;v3）。 pnpm 可以在一个电脑上不同的磁盘设置同一个分区，在这种情况下，pnpm 将复制包而不是硬链接它们，因为硬链接只能发生在同一文件系统同一分区上 npm 在安装时，不会去检查缓存；而 pnpm 在安装时，会先检查是否有对应包及其版本的缓存，如果有的话，直接硬链接到这个缓存地址 模块依赖 pnpm 使用平铺的方式，类似于npm2的结构，但是增加了一个.pnpm目录，其中的包命名格式如下： 12 .pnpm/&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;// 组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称) 对于 PeerDependencies 来说，命名规则稍许不同 12.pnpm/&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;_&lt;organization-name&gt;+&lt;package-name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;// peerDep组织名(若无会省略)+包名@版本号_组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称) pnpm 使用硬链接，将 node_modules 的包地址硬链接到 pnpm 的缓存中；对于同包同版本使用符号连接. npm 与 pnpm 差别 功能 pnpm npm 隔离的 node_modules ✅ ❌ 自动安装 peers ✅ 通过 auto-install-peers&#x3D;true ✅ Plug’n’Play(即插即用) ✅ ❌ 管理 Node.js 版本 ✅ pnpm env &lt;cmd&gt; ❌ 内容可寻址存储 ✅ ❌ Side-effects cache(缓存的副作用) ✅ ❌ 有锁文件 pnpm-lock.yaml package-lock.json 即用即删 pnpm dlx npx 参链 npm npm 模块安装机制与实现原理 npm 和 package.json 那些不为常人所知的小秘密 npx npx 简介 npx 是什么命令？npx 和 npm 有什么区别？ pnpm pnpm","categories":["额外内容"]},{"title":"Chrome的Performance","path":"/2024/02/06/Chrome--performance/","content":"Chrome 的 performance开始记录可以通过调整这两个参数模拟低网低 cpu 情况 点击按钮，刷新页面或者只需要旁边的刷新按钮开始进行记录分析 操作设置栏 controls 可以通过这个下拉框看到之前的分析数据 其他配置 页面性能的高级汇总 overview 颜色表示 HTML 脚本 样式 媒体资源 其他资源 名称 描述 FPS，帧数 绿色竖线越高，FPS 越高。 FPS 图表上的红色块表示长时间帧，很可能会出现卡顿 CPU，CPU 资源 指示消耗 CPU 资源的事件类型 NET，网络请求 每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间），可以在屏幕快照下面查看具体的网络请求数据 火焰图： CPU 堆叠可视化 Timing FCP: First Contentful Paint，白屏时间，第一个元素出现的时间 LCP: Largest Contentful Paint，视窗最大可见图片或者文本块的渲染时间 FMP: First Meaningful Paint，首次有效绘制时间，页面的“主要内容”开始出现在屏幕上的时间点 DCL: DOMContentLoaded Event，dom 加载完毕时间 L: Onload Event，完全加载完毕时间 名称 描述 Network 资源加载顺序及时长 Main 渲染进程中主线程的执行记录，点击 main 可以看到某个任务执行的具体情况 Timings 用户交互操作，比如点击鼠标、输入文字、动画等 Compositor r 合成线程的执行记录，用来记录 html 绘制阶段 (Paint)结束后的图层合成操 Raster 光栅化线程池，用来让 GPU 执行光栅化的任务 GPU GPU 进程主线程的执行过程记录，如 可以直观看到何时启动 GPU 加速 Frame ifream 框架加载详情 Memory 不同的时间段的执行情况。页面中的内存使用的情况 在火焰图上看到一到三条垂直的虚线。蓝线代表 DOMContentLoaded 事件。 绿线代表首次绘制的时间。 红线代表 load 事件 如果是耗时长的 Task，其右上角会标红，这个时候，我们可以选中标红的 Task，然后放大，看其具体的耗时点。放大后，这里可以看到都在做哪些操作，哪些函数耗时了多少,这里代码有压缩，看到的是压缩后的函数名。然后我们点击一下某个函数，在面板最下面，就会出现代码的信息，是哪个函数，耗时多少，在哪个文件上的第几行等。这样我们就很方便地定位到耗时函数了。 Summary性能摘要 颜色表示 Loading：网络通信和HTML解析 Scripting：JavaScript执行 Rendering：样式计算和布局，即重排 Painting：重绘 other：其它事件花费的时间 Idle：空闲时间 事件包含 参考Chrome Performance 使用栗子 Chrome Performance 页面性能分析指南 饼状图分析 performance","categories":["浏览器"]},{"title":"【小程序】上传文件","path":"/2024/02/06/【小程序】上传文件/","content":"小程序上传文件选择文件拍摄或从手机相册中选择图片或视频。wx.chooseMedia 1234567891011121314151617181920212223/** * @description: 拍摄或从手机相册中选择图片或视频。 * @param &#123;*&#125; mediaType 文件类型 mix/video/image * @param &#123;*&#125; count 最多可以选择的文件个数，基础库2.25.0前，最多可支持9个文件，2.25.0及以后最多可支持20个文件 * @param &#123;*&#125; sourceType 图片和视频选择的来源 [&quot;album&quot;, &quot;camera&quot;] * @param &#123;*&#125; maxDuration 拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 60s 之间。不限制相册。 * @param &#123;*&#125; camera 仅在 sourceType 为 camera 时生效，使用前置或后置摄像头 * @return &#123;*&#125; 文件内容 */wx.chooseMedia(&#123; count, mediaType: [mediaType], sourceType, maxDuration, camera, success(res) &#123; return res; &#125;, fail(err) &#123; console.log(&quot;文件chooseMedia失败-----&quot;, err); reject(err); &#125;,&#125;); 从聊天会话选择文件。wx.chooseMessageFile 12345678910111213141516171819/** * @description: 从会话选择文件。 * @param &#123;*&#125; type 所选的文件的类型 * @param &#123;*&#125; count 最多可以选择的文件个数，可以 0～100 * @param &#123;*&#125; extension 根据文件拓展名过滤，仅 type==file 时有效。每一项都不能是空字符串。默认不过滤。 * @return &#123;*&#125; 文件内容 */wx.chooseMessageFile(&#123; count, type, extension, success(res) &#123; onHandleFile(res, &quot;path&quot;).then((data) =&gt; reslove(data)); &#125;, fail(err) &#123; console.log(&quot;文件chooseMedia失败-----&quot;, err); reject(err); &#125;,&#125;); 上传到后端调用 uploadFile 选择文件后，调用uploadFile传入本地路径，即可进行文件上传 123456789101112131415161718192021222324252627282930/** * @description: 进行文件上传 * @param &#123;*&#125; url 文件上传地址 * @param &#123;*&#125; filePath 要上传文件资源的路径 (本地路径) * @param &#123;*&#125; name 文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容 * @param &#123;*&#125; formData HTTP 请求中其他额外的 form data * @param &#123;*&#125; header HTTP 请求 Header，Header 中不能设置 Referer */new Promise((reslove, reject) =&gt; &#123; wx.showLoading(&#123; title: &quot;上传中...&quot;, mask: true, &#125;); wx.uploadFile(&#123; url, filePath, name, formData, header, success: (res) =&gt; &#123; reslove(res); &#125;, fail: (err) =&gt; &#123; reject(err); &#125;, complete: () =&gt; &#123; wx.hideLoading(); &#125;, &#125;);&#125;); 上传到腾讯云此方式在选择文件后，直接调用接口，无需再调用uploadFile 下载 sdk在腾讯云小程序上传中下载cos-js-sdk-v5.min.js文件，放入项目中 引入及配置1const cosSDK = require(&quot;../static/js/cos-js-sdk-v5.min.js&quot;); 进行腾讯云的 sdk 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 //生成随机数 const getRandomSecret = (num: number) =&gt; &#123; let t = &quot;xxx&quot;, a = t.length, n = &quot;&quot;; for (let i = 0; i &lt; num; i++) n += t.charAt(Math.floor(Math.random() * a)); return n; &#125;; //获取十位的时间戳 const getTimeStamp = (date?) =&gt; &#123; return Math.floor(new Date(date).getTime() / 1000); &#125;; //获取密钥 const getSDKToken = (fileName: string) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 通过后端获取密钥 getCosToken(&#123;&#125;).then( (res) =&gt; &#123; const &#123; access_secret_id, access_secret_key, expiration, security_token, config, &#125; = res ?? &#123;&#125;; const &#123; bucket, region, tenant_id &#125; = config; const fileType = fileName.split(&quot;.&quot;).pop(); const ExpiredTime = getTimeStamp(expiration); const StartTime = getTimeStamp(new Date()); const random = getRandomSecret(7); uploadParams.Bucket = bucket; uploadParams.Region = region; //文件名是13位时间戳和7位随机数 uploadParams.Key = `$&#123;tenant_id&#125;/$&#123;StartTime&#125;$&#123;random&#125;.$&#123;fileType&#125;`; const cosInitParams: TCosInitParams = &#123; TmpSecretId: access_secret_id, TmpSecretKey: access_secret_key, SecurityToken: security_token, StartTime, ExpiredTime, &#125;; resolve(cosInitParams); &#125;, () =&gt; &#123; reject(&#123;&#125;); &#125; ); &#125;); &#125;; //配置sdk const configSDK = (params) =&gt; &#123; return new Promise((resolve) =&gt; &#123; cos = new cosSDK(&#123; getAuthorization: (options, callback) =&gt; callback(params), FileParallelLimit: 10, ChunkParallelLimit: 10, &#125;); resolve(&quot;success&quot;); &#125;); &#125;; //上传文件 const onUpload = (filePath) =&gt; &#123; return new Promise((resolve) =&gt; &#123; cos?.uploadFile( &#123; ...uploadParams, FilePath: filePath, onProgress: function (progressData) &#123; /* 非必须 */ console.log(&quot;--------onProgress--------&quot;); &#125;, &#125;, (err, data) =&gt; &#123; resolve(err || data); &#125; ); &#125;); &#125;;/** * @description: 开始cos上传 * @param &#123;*&#125; fileName 选择的文件名称 * @param &#123;*&#125; filePath 本地临时文件路径 (本地路径) * @param &#123;*&#125; fileSize 本地临时文件大小，单位 B * @param &#123;*&#125; fileType 选择的文件类型 * @return &#123;*&#125; */ const onStartUpload = async (fileName, filePath, fileSize, fileType) =&gt; &#123; // 因为从手机选择文件上传无法获取文件名称，如果在无名称时上传，那么会报错 if (!fileName) &#123; fileName = filePath.slice(filePath.indexOf(&quot;//&quot;) + 1); &#125; const sdkParams: TCosInitParams | &#123;&#125; = await getSDKToken(fileName); wx.showLoading(&#123; title: &quot;上传中...&quot;, mask: true, &#125;); return new Promise((resolve, reject) =&gt; &#123; configSDK(sdkParams as TCosInitParams).then(() =&gt; &#123; onUpload(filePath).then( (data: TCosUploadResponse) =&gt; &#123; const params = &#123; cos_file_name: fileName, cos_file_size: fileSize, cos_file_type: fileType, cos_url: data.Location, &#125; const &#123; cos_url, cos_file_name &#125; = params; //如果是视频的话需要额外传视频首祯图和视频封面 if (judgeFileType(cos_url) === &quot;video&quot;) &#123; const screen = getVideoScreen(cos_url); getThumbnailLogo(screen, cos_file_name).then( (res: TGetThumbnailLogoResponse) =&gt; &#123; const &#123; screen: logo &#125; = res ?? &#123;&#125;; wx.hideLoading(); resolve(&#123; ...params, cos_video_file_screen: screen, cos_video_thumbnail_logo: logo, &#125;); &#125; ); &#125; else &#123; wx.hideLoading(); resolve(params); &#125; &#125;, (error) =&gt; &#123; wx.hideLoading(); reject(error); &#125; ); &#125;); &#125;); &#125;; 使用12345678910111213141516uni.chooseMessageFile(&#123; count, type, extension, success(res) &#123; const tempFilePaths = res.tempFiles; const &#123; name, path, size, type &#125; = tempFilePaths[0]; onStartUpload(name, path, size, type).then((res) =&gt; &#123; reslove(res); &#125;); &#125;, fail(err) &#123; console.log(&quot;文件chooseMedia失败-----&quot;, err); reject(err); &#125;,&#125;);","categories":["小程序"]},{"title":"【小程序】uniapp发布插件","path":"/2024/02/06/【小程序】uniapp发布插件/","content":"【小程序】uniapp发布插件uni-modules-插件 新建发布uni_modules插件 在uni_modules右键，选择新建一个uni_modules插件 此时会生成一个插件模板代码 写好对应的文件后，在插件目录右键，选择发布到插件市场 填写好对应的信息后，直接进行保存即可 发布好后，即可在uniapp插件市场中进行下载 更新插件 更新好具体的内容后，右键选择发布到插件市场 更新即可 注意点 发布和导入是同一个项目 项目里面如果又导入了这个插件，那么在uni_modules下导入的插件会被覆盖 发布的包必须包含的文件 components/插件名/插件名.vue 如果没有这个文件，那么在发布时会报错 package.json 用于配置发布插件的一些信息","categories":["小程序"]},{"title":"【手写】call、apply、bind","path":"/2024/02/06/【手写】call、apply、bind/","content":"callcall 可以改变调用函数时的 this 指向，当调用但什么都不传入时，默认是 window 对象 内部流程es 文档上编写的流程如下: 让一个函数 func 指向 this 如果这个函数 func 不能被调用，那么抛出 TypeError 准备尾调用 PrepareForTailCall 返回执行结果 思路 判断需要改变的 context 是否为空，如果为空，那么就默认指为 window。保留这个新的 context，作为后面函数调用时需要的 this 指向 将当前的 this 指向赋值给上一步保留的 context，作为 context 的一个属性 调用第一步保留的 context 的第二步赋值的属性函数，将所需要的参数传递给上一步新赋值的属性 实现 call 12345678910111213function call_handle_writing(fn) &#123; // ctx指向obj，因为fn为非空 const ctx = fn || window; // ctx.cb指向的是fn1 ctx.cb = this; // 获取参数 const args = [...arguments].slice(1); // 调用fn1函数，但是由于是ctx调用的，那么fn1被调用的时候的this指向是ctx const res = ctx.cb(...args); return res;&#125;Function.prototype.call_handle_writing = call_handle_writing; 使用 12345678function fn1() &#123; this.a = 1; console.log(&quot;out&quot;, this, arguments);&#125;let obj = &#123; a: 100,&#125;;fn1.call_handle_writing(obj, 1, 2, 3); apply实现流程 Let func be the this value. If IsCallable(func) is false, throw a TypeError exception. If argArray is either undefined or null, then a. Perform PrepareForTailCall().b. Return ? Call(func, thisArg). Let argList be ? CreateListFromArrayLike(argArray). Perform PrepareForTailCall(). Return ? Call(func, thisArg, argList). 其实就是接受一个数组作为参数，实际最后的调用时，调用的也是 call 方法 apply 调用 call 的时候，会用到扩展运算符，将参数放到 call 的参数中，因此这在一定程度上，导致了 apply 的性能会稍低于 call 具体实现1234567function apply_handle_writing(fn, params) &#123; if (Array.isArray(params)) &#123; return this.call_handle_writing(fn, ...params); &#125; return this.call_handle_writing(fn);&#125;Function.prototype.apply_handle_writing = apply_handle_writing; bind内部流程 Let Target be the this value. If IsCallable(Target) is false, throw a TypeError exception. Let F be ? BoundFunctionCreate(Target, thisArg, args). Let L be 0. Let targetHasLength be ? HasOwnProperty(Target, “length”). If targetHasLength is true, then a. Let targetLen be ? Get(Target, “length”).b. If targetLen is a Number, then i. If targetLen is +∞𝔽, set L to +∞. ii. Else if targetLen is -∞𝔽, set L to 0.iii. Else, Let targetLenAsInt be ! ToIntegerOrInfinity(targetLen). Assert: targetLenAsInt is finite. Let argCount be the number of elements in args. Set L to max(targetLenAsInt - argCount, 0). Perform SetFunctionLength(F, L). Let targetName be ? Get(Target, “name”). If targetName is not a String, set targetName to the empty String. Perform SetFunctionName(F, targetName, “bound”). Return F. 考虑场景： 12345function A() &#123;&#125;A.prototype.say = function () &#123;&#125;;function B() &#123;&#125;const C = A.bind(B);const c = new C(); 调用 bind 后，使用new去创建一个实例，那么在new的时候不应该改变this指向 在返回的函数中，用instanceof判断是否是通过new方法进行调用的 调用 bind 后，在 c 上面可以调用 A 上 prototype 的方法 采用继承的方式，在返回的函数上，继承 A 具体实现123456789101112131415function bind_handle_writing(fn) &#123; const that = this; const args = [...arguments].slice(1); function cb() &#123; const params = [...arguments, ...args]; fn = this instanceof cb ? this : fn; return that.call(fn, ...params); &#125; // 用一个中间函数，在原型链上加一层，防止属性覆盖 const buf = function () &#123;&#125;; buf.prototype = this.prototype; cb.prototype = Object.create(this.prototype); return cb;&#125;Function.prototype.bind_handle_writing = bind_handle_writing; 参考链接如何手写一个 bind 方法","categories":["js"]},{"title":"【前端缓存】随机数位置区别","path":"/2024/02/06/【前端缓存】随机数位置区别/","content":"文件随机数存放位置区别文件url+?+随机数 https://xxx?v=1.x.x 一般用于版本号对应的文件 https://xxx?c=s45sdf 一般用于文件内容生成的hash值 文件名+hash值https://xxxs45sdf hash值一般由文件内容生成 区别以上两种存放位置都可以使浏览器获取最新的文件，而不是走缓存拿文件 当前主流的一般是用文件名+hash值的形式。原因如下 一般发版时，是有html文件和js、css文件的。浏览器首先去请求html文件，html嵌入了js、css等其他文件。那么在请求html和js、css等文件的这个时间差内，如果采用第一种方式(文件url+?+随机数)，就容易出现问题 如果先发html文件，再发js、css等文件 客户请求时，浏览器不会走缓存，会去取最新的文件。 但是可能这个时候取的js、css文件还是老的文件。那么就导致客户端下次再去请求时，走的其实是缓存。 先发js、css等文件，再发html文件 对于有缓存的用户不会造成影响。 但是对于无缓存的用户，拿取数据时，会拿取到最新的js、css等文件，那么最直观的影响可能是页面样式问题。但当html发布成功后，页面会恢复正常 对于异步加载的情况 代码发布后，用户在使用过程中，进入了一个新路由 在新路由页面，获取的是最新的代码文件，但是在进入之前，获取的是老代码文件，那么这里就会导致新老代码文件交替，容易出现问题 因此，采用文件名+hash的方式，无论是先发html还是js、css文件，由于是直接通过文件名去获取的，那么就不会产生上述问题。 先发js、css等文件 由于文件名不同，由于文件名已经不一样了，所以不会覆盖掉之前存在的资源文件，客户端依旧可以安全的访问。 再发html文件 因为js、css等文件已经发布完毕了，那么当html更新了之后，再获取的js、css等文件就已经是最新的了 参链大公司里怎样开发和部署前端代码","categories":["浏览器"]},{"title":"【wasb】环境搭建","path":"/2024/02/06/【wasb】环境搭建/","content":"【webAsb】- Emscripten环境搭建依赖环境 python git 这两项环境是必要的，否则无法进行安装 安装下载项目1git clone https://github.com/juj/emsdk.git 下载emscripten项目 安装依赖包等1234cd emsdk // 进入项目目录中emsdk update // 安装各种工具emsdk install latest //下载各种包，时间比较长emsdk activate latest //生成 ~/.emscripten 文件，激活配置 配置环境变量可以先执行emsdk_env脚本，这个脚本默认会写入环境变量，但是也会有不成功的情况。 在非emsdk目录下执行emcc --version，判断是否报错，如果报错，就证明环境并未配置成功；如果未报错，那么环境已经配置完成啦 环境未配置成功 执行 emcmdprompt.bat命令 将带有PATH +=的路径写入环境变量的Path中 将下面带有键值对的写入系统变量中 记住不能有空格，否则会执行不成功 在非emsdk目录下执行emcc --version 环境配置成功 配置c++环境安装配置c&#x2F;c++ 安装 安装c&#x2F;c++编译器：https://sourceforge.net/projects/mingw-w64/ 配置 在环境变量的Path中，把解压的mingw的bin目录加入进去 测试在cmd输入gcc -v，没有报错即可 参链 测试编写测试程序建立一个cpp文件，写入c的代码 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl; return 0;&#125; 生成js代码 emcc test.cpp -o test.html 会生成html，js和wasm文件，html默认引入js文件，js的作用是引入wasm文件 -s 表明编译到 Wasm，否则编译到 Asm.js（Wasm 的前身）， 最初 emscripten 是用于编译到 Asm.js 的。 SIDE_MODULE 表明编译为副模块。有副模块就有主模块，简单理解副模块会去除 C 标准库函数，因为副模块会在运行时被链接到一个主模块，而主模块有C标准库函数。SIDE_MODULE的值可选 1 或者 2，前者会自动导出代码里所有的函数，而后者需要手动声明。 -o xxxx 导出选项，导出的文件可选 .html、.js、.wasm，区别在于前面两者会帮你把胶水代码写好 ，而 .wasm 则需要在 JS 自己编写胶水代码了，但是前面两者代码冗余，比如编译为 JS 文件时，JS 文件会包含两千多行代码，不过这是学习 Wasm 的现成实例。 搭建本地服务器在代码路径中，搭建本地服务。在浏览器访问本地的文件会报错 pnpm init 创建package.json文件 pnpm i http-server 安装http-server http-server -o 起本地服务，在浏览器打开html文件 验收用http-server起了本地服务后，在浏览器访问对应的域名加上生成的html文件，正常运行项目 参链Emscripten编译器安装教程，亲测成功编译出第一个WebAssembly","categories":["webAssembly"]},{"title":"【pwa】mainifest","path":"/2024/02/06/【pwa】mainifest/","content":"mainifest.json用途通过 manifest.json 可以实现自定义启动画面、打开 url、设置界面颜色、设置桌面图标等 常用字段123456789101112131415&#123; &quot;short_name&quot;: &quot;pwa1&quot;, &quot;name&quot;: &quot;pwa-测试用例1&quot;, &quot;icons&quot;: [ &#123; &quot;src&quot;: &quot;qr-code-fill-144.png&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; &#125; ], &quot;start_url&quot;: &quot;/test1&quot;, &quot;display&quot;: &quot;standalone&quot;, &quot;theme_color&quot;: &quot;blue&quot;, &quot;background_color&quot;: &quot;black&quot;&#125; name: string 描述应用的名称，会显示在桌面图标的标题位置和启动画面中 short_name: string 描述应用的短名称。当应用名字过长，在桌面图标无法全部显示时，会显示 shortname scope：string 设置 manifest 对于网站的作用范围。 start_url: string 描述用户从设备主屏幕点击图标进入时的第一个地址，start_url 必须在 scope 的作用范围内 如果为空，则以 manifest.json 作为 url 如果 url 打开失败，则和正常显示的网页打开错误的样式一样 如果设置的 url 和当前的项目不在一个域下，无法正常显示 如果 starturl 为相对地址，那么根路径基于 manifest 的路径 如果 starturl 为绝对路径，那么根路径为将 icon：TIcon 设置 webapp 图标集合。 12345type TIcon = &#123; src: string; //图标地址 type: string; //图标mime类型，只能为image/png sizes: string; //图标大小，用来表示width x height，单位为px，如果图标要适配多个尺寸，则多个尺寸用空格隔开。与真实图片大小要一致&#125;; 适配规则： 将 webapp 添加到桌面时，浏览器会适配最合适尺寸的图标。浏览器会首先去找与显示密度想匹配且尺寸调整为 48dp 屏幕密度的图标。例如在 2 倍像素的设备上使用 96px，3 倍像素的设备上使用 144px 的 如果没有找到合适的图标，那么会查找与设备特性匹配度最高的图标 如果图标路径错误，那么将显示浏览器的默认图标 background_color: string 启动画面的背景颜色。rgbs、hsl、hsla 等写法浏览器不支持。未设置时，默认白色 theme_color: string 显示 web app 的主题色，显示在 banner 位置 display: &#39;fullscreen&#39;|&#39;standalone&#39;|&#39;minimal-ui&#39;|&#39;browser&#39; webapp 被启动时显示的类型 orientation: &#39;landscape-primary&#39;|&#39;landscape-secondary&#39;|&#39;landscape&#39;|&#39;portrait-primary&#39;|&#39;portrait-secondary&#39;|&#39;portrait&#39;|&#39;natural&#39;|&#39;any&#39; webapp 在屏幕上的显示方向 dir: &#39;ltr&#39;|&#39;rtl&#39;|&#39;auto&#39; 文字的显示方向 related_applications: &#39;platform&#39;|&#39;id&#39; 用于定义对应的原生应用，类似应用安装横幅提示的形式去推广、引流原生应用 prefer_related_applications: Boolean 设置是否只允许用户安装原生应用 生效条件 必须是 https 或者 localhost 必须注册运行 service worker，且有 fetch 事件监听 manifest 必须要有 icons,且必须要至少有尺寸为144x144的 diaplay 设置为 standalone 或者 fullscreen 必须有 name 或者 short_name，start_url prefer_related_applications 未设置或者为 false 引导安装12345678910111213window.addEventListener(&quot;beforeinstallprompt&quot;, (e) =&gt; &#123; console.log(&quot;beforeinstallprompt&quot;); e.preventDefault(); e.prompt();//显示安装弹窗&#125;);navigator.serviceWorker .register(&quot;pwa1.js&quot;) .then((res) =&gt; &#123; console.log(&quot;service-pwa1注册成功&quot;, res); &#125;) .catch((err) =&gt; &#123; console.log(&quot;service-pwa1注册失败&quot;, err); &#125;);","categories":["PWA"]},{"title":"【HTML】templates and slots","path":"/2024/02/06/【HTML】templates and slots/","content":"【HTML】templates and slots概况可以用来灵活填充 Web 组件的 shadow DOM 的模板。可以复用相同的标记结构。 使用 编写一个 template 直接在页面中编写一个 template 不会直接在页面中显示出来 12345678910&lt;template id=&quot;test&quot;&gt; &lt;style&gt; p &#123; color: white; background-color: #666; padding: 5px; &#125; &lt;/style&gt; &lt;p&gt;测试template&lt;/p&gt;&lt;/template&gt; 注册自定义模板 12345678910111213customElements.define( &quot;test-template&quot;, class extends HTMLElement &#123; constructor() &#123; super(); let template = document.getElementById(&quot;test&quot;); let templateContent = template.content; const shadowRoot = this.attachShadow(&#123; mode: &quot;open&quot; &#125;); shadowRoot.appendChild(templateContent.cloneNode(true)); &#125; &#125;); 组件显示 1&lt;test-template /&gt; 页面显示 template 的元素的样式也是独立的，并不会因为父级定义的同一个样式而影响内部。 虽然 template 和使用在同一个页面，但是如果直接在 Elements 面板里面修改 template 的内容，不会影响到渲染的地方。 添加 slot 添加的slot的样式只收到父级的影响，并不会受到template中定义的样式影响 如果是template中并没有定义对于的slot，那么传入的slot并不会被渲染 12345678910111213141516&lt;template id=&quot;test&quot;&gt; &lt;style&gt; p &#123; color: white; background-color: #666; padding: 5px; &#125; &lt;/style&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name=&quot;text1&quot;&gt;&lt;/slot&gt; &lt;p&gt;测试template&lt;/p&gt;&lt;/template&gt;&lt;test-template&gt; &lt;p&gt;默认slot的内容&lt;/p&gt; &lt;p slot=&quot;text1&quot;&gt;具名插槽的内容&lt;/p&gt;&lt;/test-template&gt; 获取slot名 12345let el = document.querySelectorAll(&#x27;test-template p&#x27;) el.forEach(ele=&gt;&#123; console.log(ele.slot) &#125;)// 输出：&quot;&quot;, &quot;text1&quot;, &quot;text2&quot; 参链使用 templates and slots shadow dom解析","categories":["HTML"]},{"title":"【HTML】Shadow DOM","path":"/2024/02/06/【HTML】Shadow DOM/","content":"【HTML】Shadow DOM概况定义能够为 Web 组件中的 DOM 和 CSS 提供了封装，实际上是在浏览器渲染文档的时候会给指定的 DOM 结构插入编写好的 DOM 元素，但是插入的 Shadow DOM 会与主文档的 DOM 保持分离，也就是说 Shadow DOM不存在于主 DOM 树上。shadow root 节点为起始根节点，在这个根节点的下方，可以是任意元素，和普通的 DOM 元素一样。 并且 Shadow DOM 封装出来的 DOM 元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部。 查看控制台-》设置按钮-》Preference -》 Elements -》点击 show user anent shadow dom 的 checkbox 打开之后可以看到一些元素的真实布局及内容组成。 结构 Shadow host：一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。 Shadow tree：Shadow DOM 内部的 DOM 树。 Shadow boundary：Shadow DOM 结束的地方，也是常规 DOM 开始的地方。 Shadow root: Shadow tree 的根节点。 custom element(自定义标签)概况可以注册一个自定义标签，CustomElementRegistry提供注册自定义元素和查询已注册元素的方法，使用customElements可以直接获取其实例。 方法 方法名 作用 参数 返回值 customElements.define 定义了一个自定义元素 name: 自定义元素名; constructor: 自定义元素构造器; options: 控制元素如何定义(目前只支持extends) - customElements.get 返回以前定义自定义元素的构造函数 name: 返回引用的构造函数的自定义元素的名字 指定名字的自定义元素的构造函数，如果没有使用该名称的自定义元素定义，则为undefined。 customElements.upgrade 将更新节点子树中所有包含阴影的自定义元素，甚至在它们连接到主文档之前也是如此 root: 待升级的包含阴影的派生元素节点 - customElements.whenDefined 当一个自定义节点被定义时走入then，如果这个元素名没有被定义，那么返回的是一直pending状态 name: 自定义元素名 Promise 使用1customElements.define(&quot;test-shadow-dom&quot;, TestShadowCls) 使用挂载 shadow dom可以调用Element.attachShadow将 Shadow Dom 选择挂载或者卸载。此方法返回的是一个类 dom，可以像操作普通 dom 一样对其进行操作 参数名 作用 可选值 mode 指定 Shadow DOM 树封装模式的字符串 open&#x2F;closed delegatesFocus 焦点委托 boolean 挂载 1234const shadow = el.attachShadow(&#123; mode: &quot;open&quot;,&#125;);console.dir(shadow); 操作 shadow dom 12const html = `&lt;p&gt;测试1&lt;/p&gt;`;shadow.innerHTML = html; 自定义元素Shadow DOM 可以渲染自定义的元素，类似于 vue3 中的组件，但里面的样式并不互相干扰。 新建类 12345class TestShadowCls extends HTMLElement &#123; constructor() &#123; super(); //必要的，因为属于子类 &#125;&#125; 创建一个 Shadow DOM 并为其加上需要的数据 123456789101112131415161718addShadow()&#123; this.shadow = this.attachShadow(&#123; mode: &quot;open&quot; &#125;)&#125;createChild()&#123; const el = document.createElement(&quot;div&quot;); const pel = document.createElement(&quot;p&quot;); pel.textContent = &quot;测试文案&quot;; pel.setAttribute(&quot;class&quot;, &quot;test&quot;) const imgae = document.createElement(&quot;img&quot;); imgae.setAttribute(&quot;src&quot;, &quot;https://psstatic.cdn.bcebos.com/video/wiseindex/aa6eef91f8b5b1a33b454c401_1660835115000.png&quot;) imgae.src=&quot;https://psstatic.cdn.bcebos.com/video/wiseindex/aa6eef91f8b5b1a33b454c401_1660835115000.png&quot;; el.appendChild(pel); el.appendChild(imgae) this.shadow.appendChild(el)&#125; 定义自定义的元素名 1customElements.define(&quot;test-shadow-dom&quot;, TestShadowCls) 使用 123456&lt;style&gt; p&#123; color: red; &#125;&lt;/style&gt;&lt;test-shadow-dom /&gt; 渲染效果如下，里面的文案并没有因为style加上的元素样式而生效 添加样式 12345678910createClass()&#123; const style = document.createElement(&quot;style&quot;); style.textContent = ` .test&#123; color: blue; font-weight: 600 &#125; ` this.shadow.appendChild(style)&#125; 加上了之后，样式生效 参链使用 shadow DOM 究竟什么是 Shadow DOM？","categories":["HTML"]},{"title":"【devTools】常用面板","path":"/2024/02/06/【devTools】常用面板/","content":"【devTools】常用面板Elements面板将元素存入变量 右击 选择store as global variable 通过$0、$1…获取对应的元素 console面板自动合并相似信息Group similar message in console，浏览器默认开启的 Hide network隐藏网络的错误提示信息 preserve log页面跳转时保留console信息 show timestamps打印时，会默认输入每一行信息的时间 打开：devtools右上角设置按钮，perferces下show timestamps $_作用：获取最近一次的执行结果 $和$$$：document.querySelector $$: document.querySelectorAll $x可以使用xpath选择元素。 eg：$x(“&#x2F;html&#x2F;body&#x2F;div”) debug执行到该函数时就会触发断点 12345const fn = () =&gt; &#123; return 1;&#125;debug(fn)fn() monitor函数执行时打印参数值，但无法打印箭头函数的参数 执行unmonitor删除效果 123456function fn3(a, b)&#123; return a+b&#125;monitor(fn3)fn3(1,2)//输出：VM3370:1 function fn3 called with arguments: 1, 2 monitroEvents监听并打印元素触发的事件，可以用数组一次性监听多个事件。 执行unmonitorEvents取消监听 getEventListeners获取注册在元素上的所有事件监听器 queryObjects获取所有原型链中包含该原型的对象 source面板FileSystem可以直接与本地的文件连接，在devtools修改文件之后，会将本地的文件内容也进行修改 overrides可以以本地的文件取代页面中载入的资源 断点条件断点在source代码块需要设置时，在对应的行号右键，选择Add Condition Break Point，写上具体的条件 断点打印信息，Logpoint在执行时经过该程序代码时打印信息 dom断点在element tab，右键元素，展开break on，有三种断点形式： subtree modifications ：元素内发生变化时暂停，如添加、删除、修改子节点 attribute modifications ：添加、删除、修改元素本身的属性时暂停 node removal：元素被删除时暂停，同时删除dom断点 请求断点在debugger时，点击在XHR&#x2F;fetch Breapoints列表右上角的+按钮，输入data，回车保存。 事件监听器断点在debugger时，在Event Listener BreakPoint列表的Control下勾选对应的事件，然后手动触发对应的事件 忽略进入文件在对应的文件代码内容区域，右键选择Add script to ignore list，添加之后，这个文件就不会在调试时进入了 NetWork设置区域 Use large request rows 使用宽版的流量记录列表来显示 Group by frame 将来自相同iframe的请求聚焦在一起 show overview 是否显示时间轴 Capture screenslots 是否截图","categories":["浏览器"]},{"title":"【devTools】performance","path":"/2024/02/06/【devTools】performance/","content":"Performance面板开始前提 保持环境整洁，例如使用隐私模式、清除缓存等 确定目标，在执行过程中，尽可能缩短持续时间，避免额外的操作等 开始记录 打开devTools，切换到Performance面板 点击左上角的圆形按钮开始记录 记录过程种可以做一些交互 点击stop停止监测 生成内容 工具栏：与整体面板有关的操作选项和设置 overview图表：可视化呈现完整时间轴的基本信息 Activities：将性能信息以方块式的Activity为单位显示在不同种类的列表中 工具栏 Disabled Javascript Call StackMain列表不会显示js的Call stack信息 Enable advanced paint instrumentation记录绘制性能的详细信息，并显示在 Frames：Frame activity的Layers分页 Main：Paint activity的Paint Profiler分页 Overview图表 名称 描述 FPS，帧数 绿色竖线越高，FPS 越高。 FPS 图表上的红色块表示长时间帧，很可能会出现卡顿 CPU，CPU 资源 指示消耗 CPU 资源的事件类型 NET，网络请求 每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。 每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间），可以在屏幕快照下面查看具体的网络请求数据 FPS绿色方块：每秒帧数的变化，红色、粉色横条为低帧数警告，即可能会让用户感受到卡顿的部分 CPU 灰色：浏览器内部的工作 蓝色：HTML请求、文件解析 黄色：事件、js 绿色：图像处理、画面绘制 紫色：样式计算 NET 蓝色：有请求正在执行 深色：优先权较高的请求 ActivitiesMain 作用 显示主线程所有的任务，持续事件超过50ms（长任务）的任务会以红色虚线和右上角的三角形标识 任务底下的Activities依据类型有不同颜色，黄色的js Activity底下以随机颜色显示Call Stack Activities Network 左侧的细线：连接至发送请求前 浅色区域：等待服务器响应 深色区域：下载资源 右侧的细线：解析资源 左上角的小方块：请求优先级，深色表示高，浅色表示浅 Frames显示每一帧画面的详细信息 Timeings显示网页使用的重要时间点 DCL：HTML已经加载且解析完毕 FP：绘制出默认背景颜色之外的任何内容 FCP：绘制出任何文字、图片、有颜色的canvas时 LCP：绘制出页面最大的内容时 L：解析HTML期间请求的资源都载入完成时 Experience显示所有元素位移并计算分数，越低表示页面稳定性越高 GPU显示GPU的使用事件 Raster定义：浏览器渲染流程中Paint阶段的一环 作用：显示产生Raster时各个线程的信息 信息面板： summary：显示activity的持续时间，并将期间发生的其他activities分类显示 botton-up：将同一种activity的运行时间加总 call tree：以触发关系自上而下显示activities，最上方的称为root activity，是下面各个activities的起点 event log：以时间顺序显示activities 注：activity占用主线程超过50ms会被加上红色三角形，成为long task Summary显示该Activity的持续事件，并将期间发生的其他Activists分类显示 call tree call tree会显示任务由哪些activities组成，若activity的类型为程序代码，则层层展开可以看到函数的call stack self time 函数本身的运行时间，并不包含函数执行其他函数的时间 total time 函数本身和其下所有函数的运行时间的总和 bottom-up会将同一种activity的运行时间加总，因此分页中self time较长的函数通常是性能瓶颈的来源 注：总运行时间长也可能是因为执行次数多 Event Log以触发事件顺序显示Activities performance monitor打开1、在devtool按esc打开drawer，在左上角三个点打开 2、在devtools右上角的三个点，打开more tools打开 作用实时监测性能信息，用于检查特定功能是否存在内存泄漏的问题，实时反应内存用量的趋势。一般会把重点放在js heap size（js内存使用占有量）和dom tools Web VitalsLCP：前端性能指标，用于表示加载速度可以在performance的timeing中可以看到 FID：表示首次输入延迟通过rendering分页的Core Web Vitals来判断 CLS：表示累计布局偏移通过performance的Experience的layout shift标签","categories":["浏览器"]},{"title":"【devTools】layers","path":"/2024/02/06/【devTools】layers/","content":"【devTools】layers元素绘制可以查看哪些元素正在绘制 打开 在devtools页面按esc，点击左上角的三个点，打开rendering分页 勾选对应的选项 页面表现 勾选了paint flashing 元素正在绘制时，会由绿色小框表示 勾选layer borders 可以显示每个图层的区域范围 layers打开在devtools右上角三个点，点击more tools，点击layers打开layers标签 效果 可以显示当前页面存在哪些图层，对于具体的图层，可以看到其对应的大小、产生原因及内存占有量","categories":["浏览器"]},{"title":"【css】属性值定义语法","path":"/2024/02/06/【css】属性值定义语法/","content":"【css】属性值定义语法css属性定义语法是专门用于限定css属性合法取值的语法，其包含3种基本组成元素： 关键字 数据类型 符号 分类关键字其分为通用关键字和全局关键字 通用关键字： auto, none, ease等是通用关键字，或者称为普通关键字，这些只能被一部分的css属性支持 全局关键字 inherit, initial, unset和revert是全局关键字，被所有css属性支持的特殊关键字 数据类型css的数据类型有很多，至少有50个，例如number、percent、rgb等，这些都是。以及还有shape-box，basic-shape，image也属于数据类型 shape-box box、margin-box、content-box、padding-box、border-box都是属于其支持的属性值 basic-shape inset()、circle()、ellipse()、polygon()、path()、clip-path和offset-path都属于 image ，，element()，image()，image-set()，cross-fade()，paint() 符号css的符号分为字面符号、组合符号以及数量符号 字面符号指css属性种原本就支持的合法符号，这些符号会在css语法中按照其原本的字面意思呈现 符号 名称 描述 , 并列分隔符 用于分隔数个并列值，或者分隔函数的参数值 &#x2F; 缩写分隔符 用于分隔一个值的多个部分，在css缩写中用于分离类型相同但属于不同css属性的值，以及用在部分css函数中 组合符号用于表示数个基本元素之间的组合关系 符号 名称 描述 并列 符号为空格字符，表示各部分必须出现，同时需要按照顺序出现 &amp;&amp; 与 各部分必须出现，但可以不按顺序出现 || 或 各部分至少出现一个，可以不按顺序出现 | 互斥 各部分恰好出现其中一个 [] 方括号 将各部分进行分组以绕过上面几个符号的优先规则，其优先级最高 数量符号用于描述一个元素可以出现次数，数量符号不能叠加，且优先级高于组合符号 符号 名称 描述 无数量符号 恰好出现一次 * 星号 可以出现任意次数 + 加号 可以出现一次或者多次 ？ 问号 可以出现零次或者一次 {A, B} 花括号 出现最少A次，最多B次 # 井号 可以出现一次或者多次，但多次出现时必须以逗号分隔 ！ 叹号 表示当前分组必须产生一个值，该符号多出现在组合符号方括号的后面","categories":["css"]},{"title":"【css】记录小点","path":"/2024/02/06/【css】记录小点/","content":"border：0与border：none区别相同点两者都可以将元素的边框设为不可见 不同点 性能差异 border：0 其表示为将元素边框设置为0像素，虽然在页面上无法看见，但是浏览器依旧会对边框进行渲染。因此渲染的是一个像素为0的b order。 即border：0依旧会占用内存 border：none 其表示的是将元素边框设置无，因此浏览器在解析时，并不会对其进行渲染 即其不会占用浏览器内存 兼容 在ie6&#x2F;7的button元素中，border：none并不会生效 垂直居中图片123display: table-cell;// 子元素vertical-align: center; 文字 line-height 12height: 20px;line-height: 20px; line-height line-height指的是两行文字基线与基线之间的高度 单位为%时，计算规则是相对于当前元素的font-size计算的，即0.x*fontsize 无单位时，是相对于当前元素的font-size计算的，即x*fontsize vertical-align 元素没有设置时，继承的是父元素line-height的像素值，即如果父元素的line-height是%单位，那么浏览器计算出来的实际line-height值才会被子元素继承。 元素选择器 选择器 说明 # id选择器 . class选择器 M N 后代选择器，选择M元素内部后代的所有N元素 M&gt;N 子代选择器，选择M元素内部后代的第一个子级N元素 M～N 兄弟选择器，选择M元素后所有的同级N元素 M+N 相邻选择器，选择M元素相邻的下一个N元素，M和N是同一级 包含块作用与css盒子模型类似。作用是为这个矩形内部的后代元素提供一个参考，一个元素的大小和定位往往是由该元素所在的包含块决定的。 类型 根元素 html元素，它没有父元素，是页面中最顶端的元素。根元素存在的包含块，被称为初始包含块。 固定定位元素 若元素的position&#x3D;fixed，那么它的包含块是当前可视窗口，即当前浏览器的窗口 静态定位和相对定位元素 若元素的position&#x3D;relative&#x2F;absolute，那么其包含块是由离他最近的块级祖先元素创建的。祖先元素必须是block、inline-block或table-cell 绝对定位元素 若元素的position&#x3D;absolute，那么其包含块是最近的position！&#x3D;static的元素。祖先元素可以是块元素，也可以是行内元素 emem是相对于当前元素的父元素计算的 但是当用于fontsize时，如果多有个嵌套的元素，那么从父层到子层，其元素字号会越来越小 background-size: auto 渲染规则 如果图像没有内在尺寸和内在比例 按背景定位区域的大小进行渲染，等同于设置属性100% 水平和垂直方向同时具有内在尺寸 按图像原始大小进行渲染 没有内在尺寸，但有内在比例 渲染效果等同于contain 只有一个方向有内在尺寸，但具有内在比例 图像会拉伸到该内在尺寸的大小，同时宽高比符合内在比例 只有一个方向有内在尺寸，没有内在比例 图像有内在尺寸的一侧会拉伸到该内在尺寸大小，没有设置内在尺寸的一侧会拉伸到背景定位区域大小 ##background-size：一个为auto，一个为非auto 有内在比例 会拉伸到指定的尺寸，宽高依然保持原有的比例 没有内在比例 图像会拉伸到指定尺寸。 如果图像有内在尺寸，则auto到计算尺寸就是图像的尺寸 如果图像没有内在尺寸，那么auto的计算尺寸就是背景定位区域的尺寸 background-position 只有一个值 例如：20px &#x3D;&#x3D; 20px center 如果只有一个值，那么无论是具体的数值或者百分比或者是关键字，另一个值一定是center 两个值 两个都是关键属性值 left、right表示水平，top、bottom表示垂直。 不能包含对立的方位，即top bottom是无效的 一个是关键属性值，一个是数值或者百分比 如果第一个值是百分比或者数值，那么表示水平方向，另一个关键属性值表示垂直方向 如果第一个值是关键属性值，那么表示水平方向，另一个百分比或者数值表示垂直方向 两个值都是数值或者百分比 第一个表示水平方向，第二个表示垂直方向 3个值或者4个值 数值和百分比表示偏移量，第一个值一定要是关键属性值，这个关键属性值表示偏移方向 opacityopacity不等于1的元素会创建一个层叠上下文，层叠顺序会变高 border-raduis语法 只有一个值 表示圆角属性作用在全部四个角上 有两个值 第一个作用于左上角和右下角，第二个作用于右上角和左下角 三个值 第一个作用于左上角，第二个作用于右上角和左下角，第三个作用于右下角 四个值 按照顺时针的方向，左上、右上、右下、左下 水平半径和垂直半径12border-left-top-radius: 10px 20pxborder-raduis：10px / 20px 表示圆角是水平半径为10px，垂直半径为20px的椭圆产生的 重叠曲线f&#x3D;min(Lh&#x2F;Sh, Lv&#x2F;Sv) S为半径之和，L为元素宽高，h和v表示方向，f为计算值。 Lh：元素宽 Sh：垂直方向的半径和 Lv：元素高度 Sv：水平方向的半径和 如果f计算值小于1，那么所有圆角半径都乘以f eg： 1234border-top-left-raduis：30px 100%；border-bottom-left-raduis：30px 100%；width：150px；height：100px； 左上角和左下角的垂直半径是100%（元素高），水平半径是30pxf&#x3D;min（150&#x2F;60，100&#x2F;200）&#x3D;0.5 所以渲染结果为 12border-top-left-raduis：15px 50%；border-bottom-left-raduis：15px 50%；","categories":["css"]},{"title":"【css】滚动贴合","path":"/2024/02/06/【css】滚动贴合/","content":"【css】滚动贴合scroll-snap-type作用可以设置滚动贴合的方向和方式。 属性 none 没有贴合点的效果 x&#x2F;y 或者 inline&#x2F;block x: 可以设置水平轴上的捕捉位置 y: 可以设置垂直轴上的捕捉位置 block 可以设置块状元素排列一个滚动方向的捕捉位置，默认文档流指的是垂直方向 inline 可以设置内联状元素排列一个滚动方向的捕捉位置，默认文档流指的是水平方向 在默认文档流的情况下，这x和inline, y和block的表现都是一样的。但其实际上还是有区别的 x和y是物理轴，x对应于水平滚动，y对应于垂直滚动。 block和inline是逻辑轴，block对应于垂直滚动，inline对应于水平滚动。 在改变文档流(writing-mode)之后，那么x和inline的表现就会不一致了。 普通文档流的情况下，设置的x属性，贴合属性的生效 改变文档流的情况下，设置的x属性，贴合属性的不生效 改变文档流的情况下，设置的inline属性，贴合属性的生效 both 滚动容器会独立捕捉到其两个轴上的位置（可能会捕捉到每个轴上的不同元素） 不管是正常文档流和改变文档流后，都会被捕获 mandatory和proximity mandatory 滚动操作结束后，滚动容器必须对齐到最近的一个滚动捕捉点。无论用户滚动的距离有多远，都会强制对齐到最近的捕捉点。这种模式下，用户不能停在两个捕捉点之间。 proximity 当滚动操作结束后，只有当最近的滚动捕捉点在一定范围内时，滚动容器才会对齐到该捕捉点。如果最近的捕捉点距离太远，用户可以停在两个捕捉点之间。 所以，mandatory比proximity更严格，它会强制滚动容器对齐到最近的滚动捕捉点，而proximity则允许用户在两个滚动捕捉点之间停下。 scroll-snap-align作用用于子元素的属性，设置其捕获点 属性 start 设置捕获点为元素的起始位置 center 设置捕获点是元素居中 start 设置捕获点为元素的结束位置 scroll-margin &#x2F; scroll-padding作用可以设置贴合间距 scroll-margin是作用于子元素的，而scroll-margin是父元素才生效的。这两个属性和margin&#x2F;padding一样，可以设置例如scroll-margin-top这些属性用于不同方向的样式 scroll-behavior作用可以设置滚动时是否需要显示动画 属性 auto 默认值，表示滚动行为立即跳转到目标位置，没有过渡效果 smooth 滚动行为会平滑地过渡到目标位置，产生一种动画效果。 overscroll-behavior作用用于控制页面在滚动到底部或顶部时的行为。即如果子元素滚动到最底部后继续滚动，是否需要连带父元素滚动 属性 auto 允许滚动行为传播到父元素 contain 防止滚动行为传播到父元素，但允许页面的弹性滚动效果（比如在移动设备上，滚动到底部时页面会稍微弹一下） none 不允许滚动行为传播到父元素 兼容性 scroll-snap-type 和 scroll-snap-align：这两个属性在所有主流浏览器中都得到了支持，包括 Firefox、Chrome、Edge、Opera 和 Safari。 scroll-margin：这个属性在 Firefox 和 Chrome（包括基于 Chromium 的浏览器如 Edge 和 Opera）中得到了支持，但在 Safari 中的支持情况不太理想。 overscroll-behavior和scroll-behavior：这个属性在 Firefox 和 Chrome（包括基于 Chromium 的浏览器如 Edge 和 Opera）中得到了很好的支持，但在 Safari 中尚未被支持。","categories":["css"]},{"title":"【css】层叠上下文","path":"/2024/02/06/【css】层叠上下文/","content":"【css】层叠上下文层叠水平层叠水平，stacking level，其决定了同一个层叠上下文中元素在z轴上的显示顺序 所有元素都有层叠水平，包括层叠上下文和普通元素。但对于普通元素的层叠水平只局限于当前的层叠上下文中。 zindex在某些情况下可以影响层叠水平，但仅限于定位元素以及flex盒子的子元素，而层叠水平是所有元素都存在。 层叠顺序stacking order，其表示元素层叠时有特定的垂直显示顺序，其是规则而非概念 层叠顺序规则从下到上的顺序为： 层叠上下文 background&#x2F;border -&gt; 负zindex -&gt; block块状水平盒子 -&gt; float浮动盒子 -&gt; inline水平盒子 -&gt; zindex&#x3D;auto&#x2F;0 -&gt; 正zindex 注： 位于最下面的background&#x2F;border指层叠上下文元素的边框和背景色，每个层叠顺序规则仅适用于当前层叠上下文元素的小世界 inline水平盒子指的是 inline&#x2F;inline-block&#x2F;inline- table background&#x2F;border作为装饰属性，float&#x2F;block一般用于布局，inline都是内容，而内容的重要性是相对优先的 层叠准则当元素发生层叠的时候，其覆盖关系遵循下面两天准则 谁大谁上：当有明显的层叠水平标识时，如生效的zindex，在同一个层叠上下文领域，层叠水平值大的一个覆盖小的一个 后来居上：当元素的层叠水平一致、层叠顺序相同时，在dom流中处于后面的元素覆盖前面的元素 层叠上下文定义层叠上下文（Stacking Context）是一个HTML元素的三维概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的x轴、y轴和表示层叠的z轴。 它是页面中的一部分，决定了元素在Z轴上的堆叠顺序。在层叠上下文中，元素可以在三维空间中相对于其他元素前后排列，类似于一叠卡片。 层叠上下文的创建是可以嵌套的，也就是说一个层叠上下文内部可以包含另一个层叠上下文.在这种情况下，内部的层叠上下文会被整体地放在外部层叠上下文的某个层叠等级上，而内部层叠上下文的z-index值不会影响到外部层叠上下文的堆叠顺序。 作用 这个概念主要用于解决覆盖和重叠元素的问题，例如当元素的部分透明或定位不同导致元素重叠时，层叠上下文就会决定哪个元素在上面，哪个在下面。 特性 层叠上下文的层叠水平高于普通元素 层叠上下文可以阻断元素的混合模式 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文 每个层叠上下文和兄弟元素独立，即当进行层叠变化或者渲染时，只需要考虑后代元素 每个层叠上下文是自成体系的，当元素发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中 层叠等级 层叠等级（stacking level），又称层叠级别、层叠水平。在同一个层叠上下文中有作用。 作用 决定该层叠上下文中的层叠上下文元素在z轴上的上下顺序 在普通元素中，它决定这些普通元素在z轴上的上下顺序 层叠顺序 层叠顺序（stacking order）表示元素发生层叠时有着特定的垂直显示顺序。 注: 层叠上下文和层叠水平是概念，层叠顺序是规则 层叠上下文与层叠顺序 如果层叠上下文元素不依赖于zindex，其层叠顺序是zindex：auto，可看成zindex&#x3D;0 如果层叠上下文依赖于zindex数值，则层叠顺序由zindex决定 从下到上的顺序为： 层叠上下文 background&#x2F;border -&gt; 负zindex -&gt; block块状水平盒子 -&gt; float浮动盒子 -&gt; inline水平盒子 -&gt; zindex&#x3D;auto&#x2F;0 ，不依赖zindex的层叠上下文-&gt; 正zindex 因此，元素一旦成为定位元素，其zindex会自动生效，此时其zindex就是默认的auto，即0级别，根据上面的层叠顺序表，其会覆盖float&#x2F;block&#x2F;inline元素 触发条件创建根层叠上下文指页面根元素，可以看成是html元素. HTML中的根元素本身就具有层叠上下文，称为“根层叠上下文”。这也时绝对定位元素在没有其他定位元素限制时，会相对于浏览器窗口定位的原因。 页面中所有元素一定处于至少一个层叠结界中 定位元素与传统层叠上下文 position&#x3D;relative&#x2F;absolute position&#x3D;fixed（Firefox&#x2F;ie，不包括chrome chrome在此情景下，会将此元素作为天然层叠上下文元素 当满足上面其一条件时，zindex！&#x3D;auto时，会创建层叠上下文 css3 flex元素，同时zindex！&#x3D; auto opacity ！&#x3D; 1 mix-blend-mode ！&#x3D; normal filter ！&#x3D; none isolation &#x3D; isolate will-change为上面2～6的任意一个 -webkit- overflow-scrolling &#x3D; touch 比较规则 同一个层叠上下文中， 元素层级不同 比较“内部元素层叠级别”，层叠等级大的元素显示在上，层叠等级小的显示在下 两个元素的层叠等级相同 后面元素堆叠到前面元素的上面，即“后来者居上” 在不同层叠上下文中 比较“父级元素层叠等级”，元素显示顺序以“父级”的层叠级别来决定元素的先后顺序，与自身的层叠顺序无关 当页面中两个元素发生堆叠时，其或其祖先元素必处于同一层叠上下文（最差情况下同处根层叠上下文） 参链 层叠上下文、层叠等级、层叠顺序","categories":["css"]},{"title":"【css】contain","path":"/2024/02/06/【css】contain/","content":"【css】contain标示了元素及其内容尽可能独立于文档树的其余部分。可以防止元素内部在其包围盒外产生副作用。局限使 DOM 的一部分得以被隔离，且通过将布局、样式、绘制、尺寸或其任意组合的计算限制于 DOM 子树而非整个页面使性能受益。局限也可用于限制 CSS 计数器和引号的作用域。 局限的主要益处在于浏览器无需经常重渲 DOM 或页面布局，由此在静态页面的渲染中带来小幅性能收益，在更动态的应用中带来更多的性能收益。 允许我们指定特定的 DOM 元素和它的子元素，让它们能够独立于整个 DOM 树结构之外。目的是能够让浏览器有能力只对部分元素进行重绘、重排，而不必每次针对整个页面。著作权归作者所有。 属性值此属性为五个标准值的子集或两个简写值之一构成的以空格分隔的列表 123456789101112131415161718192021/* 关键词值 */contain: none;contain: strict;contain: content;contain: size;contain: inline-size;contain: layout;contain: style;contain: paint;/* 多个关键词 */contain: size paint;contain: size layout paint;contain: inline-size layout;/* 全局值 */contain: inherit;contain: initial;contain: revert;contain: revert-layer;contain: unset; 注：layout、paint、strict 或 content将创建： 新的包含区块（针对其 position 属性为 absolute 或 fixed 的后代元素）。 新的层叠上下文。 新的区块格式化上下文。 none元素照常渲染，不应用局限。 size在行向和块向上将尺寸局限应用于元素。元素尺寸可无视子元素单独计算。 此值不可与 inline-size 结合使用。 示例 原始代码 12345 &lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt;&lt;/div&gt;&lt;/body&gt; 12345678910111213141516.wrap &#123; width: 300px; border: 5px solid black; margin-top: 100px; min-height: 200px;&#125;.parent &#123; width: 300px; height: 200px; border: 5px solid yellowgreen;&#125;p &#123; width: 200px; height: 90px; background-color: royalblue;&#125; 12345678910function fn() &#123; document.getElementById(&quot;wrap&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123; const child = document.createElement(&quot;p&quot;); child.textContent = &quot;这是内容这是内容这是内容这是内容这是内容这是内容这是内容&quot;; document.getElementById(&quot;wrap&quot;).appendChild(child); &#125;);&#125;fn(); 修改后的 1234.wrap &#123; width: 300px;+ contain: size;&#125; inline-size将行向尺寸局限应用于元素。元素的行向尺寸可无视子元素单独计算 此值不可与 size 结合使用。 layout从页面的其余部分中隔离出元素的内部布局。此值意味着元素外的任意内容和元素内部布局互不影响。 示例 原始样式 1234567891011121314151617&lt;body&gt; &lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;p&gt;这是内容这是内容这是内容这是内容这是内容这是内容这是内容&lt;/p&gt; &lt;p style=&quot;top: 140px;&quot;&gt; 这是内容这是内容这是内容这是内容这是内容这是内容这是内容 &lt;/p&gt; &lt;p style=&quot;top: 460px;&quot;&gt; 这是内容这是内容这是内容这是内容这是内容这是内容这是内容 &lt;/p&gt; &lt;p class=&quot;float&quot;&gt;这是浮动元素这是浮动元素这是浮动元素&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;&quot;&gt; 兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819202122232425.wrap &#123; width: 300px; height: 200px; border: 5px solid black; margin-top: 100px;&#125;.parent &#123; width: 300px; height: 200px; border: 5px solid yellowgreen;&#125;p &#123; width: 200px; height: 90px; background-color: royalblue; position: fixed; top: 10px; margin-top: 10px; color: white;&#125;.float &#123; float: left; margin-top: 150px; position: inherit;&#125; 修改样式 1234567.wrap &#123; width: 300px; height: 200px; border: 5px solid black;+ contain: layout; margin-top: 100px;&#125; 这里有两个变化： 1、子元素的定位从相对于窗口定位变为了相对于父元素定位 2、子元素层级高于父元素的兄弟元素 3、浮动元素不会影响其他节点 paint元素后代不在元素边界外显示。若包含盒在屏外，则浏览器无需绘制其被局限的元素——这些元素因为完全局限于此盒故必定也在屏外。若后代元素溢出包含元素的边界，则此后代元素将被裁剪至包含元素的边框盒。 类似于overflow:hidden，但contain:paint超出的范围不会再被绘制，所以其对于性能更加友好，但是overflow的兼容性更高 示例 原始代码 12345678910&lt;body&gt; &lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;p&gt;这是内容这是内容这是内容这是内容这是内容这是内容这是内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;&quot;&gt; 兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点兄弟结点 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718.wrap &#123; width: 300px; height: 200px; border: 5px solid black; margin-top: 100px;&#125;.parent &#123; width: 300px; height: 200px; border: 5px solid yellowgreen;&#125;p &#123; width: 400px; height: 60px; background-color: royalblue; margin-top: 10px; color: white;&#125; 修改样式 1234567.wrap &#123; width: 300px; height: 200px; border: 5px solid black;+ contain: paint; margin-top: 100px;&#125; 超出父元素的内容都被隐藏掉了 style对于可在元素及其后代外产生影响的属性，其影响将不会逃离包含元素。计数器和引号的作用域被限制为元素及其内容。 示例 原始数据 123456789101112131415&lt;ul&gt; &lt;li&gt;元素甲&lt;/li&gt; &lt;li&gt;元素乙&lt;/li&gt; &lt;li&gt;元素丙&lt;/li&gt; &lt;li&gt;元素丁&lt;/li&gt; &lt;li&gt;元素戊&lt;/li&gt;&lt;/ul&gt;&lt;span class=&quot;open-quote&quot;&gt; 外 &lt;span&gt; &lt;span class=&quot;open-quote&quot;&gt;内&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;close-quote&quot;&gt;闭 &lt;/span&gt; 123456789101112131415161718ul &#123; counter-reset: list-items;&#125;li::before &#123; counter-increment: list-items; content: counter(list-items) &quot;：&quot;;&#125;body &#123; quotes: &quot;【&quot; &quot;】&quot; &quot;〈&quot; &quot;〉&quot;;&#125;.open-quote:before &#123; content: open-quote;&#125;.close-quote:after &#123; content: close-quote;&#125; li 元素按 1、2、3 排序，引号也是按顺序排列 修改后 1234567&lt;span class=&quot;open-quote&quot;&gt; 外+ &lt;span style=&quot;contain: style&quot;&gt; &lt;span class=&quot;open-quote&quot;&gt;内&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;close-quote&quot;&gt;闭 &lt;/span&gt; 123+ li:nth-last-child(2n + 2) &#123;+ contain: style;+ &#125; 变化点：1、元素计数器会重新开始，且不影响之前的数据 2、括号没有计算到第二个，直接以【为关闭 参链MDN-contain CSS新特性contain的语法、作用及使用场景 初探CSS的容器模块","categories":["css"]},{"title":"【css】border-raduis","path":"/2024/02/06/【css】border-raduis/","content":"border-raduis语法 只有一个值 表示圆角属性作用在全部四个角上 有两个值 第一个作用于左上角和右下角，第二个作用于右上角和左下角 三个值 第一个作用于左上角，第二个作用于右上角和左下角，第三个作用于右下角 四个值 按照顺时针的方向，左上、右上、右下、左下 水平半径和垂直半径12border-left-top-radius: 10px 20pxborder-raduis：10px / 20px 表示圆角是水平半径为10px，垂直半径为20px的椭圆产生的 重叠曲线f&#x3D;min(Lh&#x2F;Sh, Lv&#x2F;Sv) S为半径之和，L为元素宽高，h和v表示方向，f为计算值。 Lh：元素宽 Sh：垂直方向的半径和 Lv：元素高度 Sv：水平方向的半径和 如果f计算值小于1，那么所有圆角半径都乘以f eg： 1234border-top-left-raduis：30px 100%；border-bottom-left-raduis：30px 100%；width：150px；height：100px； 左上角和左下角的垂直半径是100%（元素高），水平半径是30pxf&#x3D;min（150&#x2F;60，100&#x2F;200）&#x3D;0.5 所以渲染结果为 12border-top-left-raduis：15px 50%；border-bottom-left-raduis：15px 50%； 渲染细节如果元素设置了border边框，则圆角半径会被分为内半径和外半径 padding边缘的圆角大小为设置的border- radius - 边框厚度 如果相邻两侧边框厚度不同，则圆角大小将在较厚和较薄边界之间显示平滑过度 圆角边框的连接线和直角边框连接线位置一致，但是角度有所不同 border-raduis不支持负值 圆角以外的区域不可点击，无法响应click事件 borser-radius没有继承性 支持transition过渡效果，支持animation动画效果","categories":["css"]},{"title":"【css】BFC","path":"/2024/02/06/【css】BFC/","content":"定义：页面中的一块渲染区域，同一个格式化上下文内和不同格式化上下文之间的定位方式都会发生变化 bfc(块级格式化上下文)创建条件 根元素 脱离普通文档流的元素(浮动，绝对定位，固定定位) 非块级元素(包含flex，table) overflow ！&#x3D;&#x3D; visible(默认值)的块级元素 影响 同一个bfc内的相邻块级元素垂直外边距会发生折叠，即两者边距取决于双方边距的最大值而不是边距和 内部元素与外部元素互不影响，因为bfc是独立容器 在计算bfc高度时，内部的浮动元素也会被计算在哪内 ifc(内联格式化上下文)形成多个内联（块级）元素排列在一起的时候，这些内联（块级）元素之间不能穿插块级元素，否则会被切割为多个ifc 影响 一个ifc内的元素都是水平排列的 横向的margin，border，padding属性对这些元素都是有效的","categories":["css"]},{"title":"解析 attrs","path":"/2024/02/06/【AST】-解析attrs/","content":"【AST】-解析 attrs考虑情况 普通情况 1class=&quot;a&quot; 空格情况 1class=&quot;a b c&quot; 无引号情况 1data = 1; 无赋值情况 1data - a; 方案前情1、attrs 作为一整串字符串传入，因为第二种(空格)情况的存在，不能通过空格进行数组分割 2、存在第二种(无引号)的情况，不能完全通过引号作为标志位进行分割 结论 以引号和等于同时作为标志位，对字符串进行切分。引号为第一准则，等号为附用 在切分 key 与 value 时，以等号作为分割符，但还需要检查 key 中是否存在空格，如果有空格，则表示存在第四种(无赋值情况)情况 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function getKeyValue(strs) &#123; // 存放key-value/attr字符的数组 let res = []; // 是否是有双引号的标志位 let is_start = false; // 是否是有等号的标志位 let is_equal = false; // 存放每个key-value的字符 let str = &quot;&quot;; // 遍历整个attrs字符串 for (let i = 0; i &lt; strs.length; i++) &#123; str += strs[i]; // 如果当前的字符是引号，那么表示一个attr值的开始或者结束，class=&quot;(开始)a&quot;(结束) if (strs[i] === `&quot;`) &#123; // 如果之前已经出现了引号，那么表示这个引号是attr的结束位，class=&quot;a&quot;(结束) if (is_start) &#123; // 那么就需要将当前收集的字符存到attr的数组中 str = str.replaceAll(&#x27;&quot;&#x27;, &quot;&quot;); res.push(str); // 需要重新收集，那么一切回到初始 is_start = false; is_equal = false; str = &quot;&quot;; &#125; else &#123; // 如果之前没有引号，那么表示这个引号是attr值的开始位，class=&quot;(开始)a&quot; is_start = true; &#125; &#125; // 如果有=，但是没有&quot;表示开始，那么就表示是x=1的形式 if (strs[i] === &quot;=&quot; &amp;&amp; !is_start) &#123; is_equal = true; &#125; // 如果当时是空格，并且是出现过等号且没有出现过引号，那么表示是data=1的情况 if (strs[i] === &quot; &quot; &amp;&amp; is_equal &amp;&amp; !is_start) &#123; // 那么就需要将当前收集的字符存到attr的数组中 res.push(str); // 需要重新收集，那么一切回到初始 is_start = false; is_equal = false; str = &quot;&quot;; &#125; &#125; // 数据已经遍历完成，但是str还没有结束 if (str) &#123; res.push(str); &#125; const data = res.reduce((pre, cur) =&gt; &#123; // 通过等号将attr的str分隔开 let [key, val = &quot;&quot;] = cur.split(&quot;=&quot;); // 去掉key的左右空格 key = key.trim(); // 如果key还存在空格，那么就表示是data-b data=1的情况 if (key.includes(&quot; &quot;)) &#123; // 需要将key以空格分割开 const keys = key.split(&quot; &quot;); // 将在最后一个key之前的key都放入attrs数组里面 for (let i = 0; i &lt; keys.length - 1; i++) &#123; pre.push(&#123; key: keys[i].trim(), val: &quot;&quot; &#125;); &#125; // 最后一个key作为对于的value值 key = keys[keys.length - 1].trim(); &#125; // 在attrs里面添加attr的key及value pre.push(&#123; key: key.trim(), val: val.trim() &#125;); return pre; &#125;, []); return data;&#125;getKeyValue( ` class=&quot;a b c &quot; id=&quot;d &quot; data-b data-c data=1 data-a=&quot;111&quot; data-d`);// 输出// res(keyvalue)数组： [&#x27; class=a b c &#x27;, &#x27; id=d &#x27;, &#x27; data-b data-c data=1 &#x27;, &#x27; data-a=111&#x27;, &#x27; data-d&#x27;]// data结果：[ &#123;key: &#x27;class&#x27;, val: &#x27;a b c&#x27;&#125;, &#123;key: &#x27;id&#x27;, val: &#x27;d&#x27;&#125;, &#123;key: &#x27;data-b&#x27;, val: &#x27;&#x27;&#125;, &#123;key: &#x27;data-c&#x27;, val: &#x27;&#x27;&#125;, &#123;key: &#x27;data&#x27;, val: &#x27;1&#x27;&#125;, &#123;key: &#x27;data-a&#x27;, val: &#x27;111&#x27;&#125;, &#123;key: &#x27;data-d&#x27;, val: &#x27;&#x27;&#125;,]","categories":["vue"]},{"title":"浏览器安全","path":"/2024/02/06/读书笔记/浏览器安全/","content":"url规范形式 scheme：&#x2F;&#x2F;[user:password@]domain:port&#x2F;path?query_string#fragments scheme 方案名，也常被当为协议名混用。一般为http、https、ftp等，告诉浏览器应该如何进行连接。浏览器在识别时不区分大小写 [user:password]。可选 验证信息，提供登陆主机的身份信息，不建议使用这种方式进行身份验证，因为传递时是明文，且并非所有浏览器都支持 domain 主机名，使用域名，主机名或者合法ip均可。如果要使用ipv6地址，则地址必须要在中括号([])中括起来，如http:&#x2F;&#x2F;[::1]。不区分域名大小写 port 端口号，表明浏览器应该连接目标的哪个端口，如果没有指定，使用默认端口（http为80，https为443） path 路径，表明浏览器获取什么数据。如果服务器的文件系统是大小写敏感，那么路径也可能是大小写敏感 query_string 查询字符串，由一个或多个“key&#x3D;value”对组成，表示需要传递给服务器的内容 fragments 片段字符，hash部分，表明文档资源的某个部分位置。例如可以让浏览器定位到锚点（通称超级链接锚点标签，anchor）的id处。一般情况下，hash值改变不会使得浏览器发出请求 安全 字形欺骗 利用字形相似来进行url的替换，例如英文l和数字1，不同国家之间的符号欺骗等 浏览器的自纠错 分解映射：浏览器会对一些字符有自动分解，会将一些特定字符分解为浏览器可识别的内容。 例如将罗马数字，cjk兼容字符，带圈数字&#x2F;英文等替换为ascii字符 httpcrlf攻击通过注入http头来篡改响应消息，，也可以构建超长的http头攻击运行着apache2.2.0～2.2.21服务器，使用户的http only的cookie泄漏 401利用浏览器的特性—当用户正在访问需要认证的资源时，服务器会响应401，浏览器收到这个状态码后，会根据服务器提供的认证提示信息弹出认证窗口。 xss-存储型：用户输入内容没有做校验 页面点击劫持将页面用iframe或者其他形式放在页面底层，用户查看的页面和实际点击的数据不一致。 -预防：x-frame-option设置页面是否支持iframe显示 中间人攻击###阻止hsts，即阻止http升级https","categories":["浏览器"]},{"title":"性能评估模型","path":"/2024/02/06/读书笔记/性能评估模型/","content":"客户端场景参数 设备特征：包括类型（pc&#x2F;手机&#x2F;pad）、硬件配置（cpu&#x2F;内存等）、操作系统（ios&#x2F;安卓等）以及操作系统版本等， 浏览器特征：品牌、版本等 网络情况：连接方式（光纤&#x2F;Wi-Fi&#x2F;移动）、运营商、地区、带宽等。 加载阶段目标领浏览器尽可能快地完成网址初始状态（即第一屏）的呈现，给用户留下良好的第一印象。 优化方向 从视觉角度提高网站内容的渲染速度 白屏时间 计算时间：将用户在浏览器地址栏中输入url按下回车那一刻作为计时起点，将有可视化的图像渲染到浏览器视窗的时间点作为计时终点，其中的差值就是白屏时间。 浏览器工作：域名查询、与web服务器建立tcp连接、发送http请求、接受并渲染文档等。 首屏时间 计算：计时终点是浏览器的第一屏首次完全渲染完毕的时间点。而计时起点有两种说法，一种是从用户按下回车键开始，即白屏时间被算入首屏时间；一种是将白屏时间的终点作为首屏时间的起点。 可交互节点 将网站首次可以响应用户操作反馈的那一刻作为可交互节点，其代表的是一个时刻而不是一个时间间隔。 从交互角度缩短从打开网站到可交互之间的时间间隔，对应可交互节点指标 首次有效绘制 对应于不同的业务，在页面上的元素有不同的优先级渲染排序。比如地图中，最重要的元素是地图本身而不是工具箱。因此为了达到更好的效益，优先级高的内容应该相对更早地展示给用户，首次有效绘制指的就是优先级最高的内容被首次渲染的时间节点 广告可视节点 更快地将广告展示给用户能间接提高与广告商之间的议价，对于公司来说，广告是非常重要甚至是主要的创收途径。 可交互阶段衡量角度 反馈速度尽可能快的响应用户的操作，根据具体的架构设计可表现在不同的角度。 动画帧率对于游戏、地图等涉及数据量庞大时，这个是需要主要的考虑点。","categories":["额外内容"]},{"title":"【webwork】介绍","path":"/2024/02/06/读书笔记/【webwork】介绍/","content":"特性 能长时间运行 启动性能理想 内存消耗理想 线程webwork依赖于浏览器（宿主环境）来实现的，从而实现了浏览器对多线程的支持 种类 dedicated worker（专用线程）：只能被首次生成它的脚本使用 shared worker（共享线程）：可以同时被多个脚本使用 模式和执行流模式 主线程提交任务 WorkerGlobal做子任务分配，分配到某个worker worker子线程分配后，将处理结果返回给WorkerGlobal，WorkerGlobal再将结果返回给主线程 执行流 主线程调用new Worker，内核异步创建worker 浏览器内核创建WebCore：Worker 主线程调用postMessage通知。 如果当时worker没有创建完成，那么会在浏览器内核中的message队列存放信息，当worker创建完成后，由浏览器内核将消息从队列中放入到worker线程中的执行循环 如果worker创建已经完成了，那么主线程直接通知到worker线程中的onmessage，不会经历浏览器内核 worker执行完成后，调用postMessage将信息传递给主线程的onmessage回调中。不经历浏览器内核 api主线程 构造 1const worker = new Worker(url, options) 注： 页面不允许启动worker，会引发security error 脚本类型只接收mime类型为text&#x2F;javascript url无法解析会导致syntaxerror","categories":["webwork"]},{"title":"【webpack】配置项","path":"/2024/02/06/读书笔记/【webpack】配置项/","content":"entrycontext在查找相对路径时，以context为根目录。默认为webpack启动时的所在工作目录。注：context必须是一个绝对路径的字符串 entry类型：string&#x2F;array&#x2F;object｜类型｜例子｜说明｜｜——-｜——-｜——-｜｜string｜index•js｜入口模块的文件路径，可以是相对路径｜｜array｜【index。js，index2。js】｜入口模块的文件路径，可以是相对路径｜｜object｜{a：index。js}｜配置多个入口，每个入口生成一个chunk｜ 如果是array，搭配output。library时，只有数组的最后一个入口文件的模块会被导出 outputfilename id：chunk的唯一标识，从0开始 name：chunk的名称 hash：chunk的唯一标识的hash值 chunkhash：chunk内容的hash 其他target代码运行的不同环境，默认为web web：针对浏览器，所有代码都集中到一个文件中 node：针对nodejs，使用require加载chunk模块 async-node：针对nodejs，异步加载chunk代码 webworker：针对webworker electron-main：针对electon主线程 electron-rendrer：针对electron渲染线程 loader svg- inline- loader：和raw- loader类似，但是会分析svg的内容，去除其不必要的部分，减少svg的体积 优化缩小文件搜索范围 loader配置 可以通过include去告诉webpack只有那些文件会被这个loader处理，用exclude排除不需要的文件 优化resolve.modules配置配置webpack去哪些目录下寻找第三方模块 指明依赖包的具体目录位置，减少查询时间。 优化reslove.main Fields配置配置第三方模块使用哪个入口文件 指明采用字段作为入口文件的描述字段，减少搜索步骤 注：需要考虑是否所有依赖包的第三方入口文件的描述字段，一个模块出错，就会导致所有的代码无法正常运行 优化reslove.alias 配置库的具体引用路径，减少查询时间 resolve.extensions 频率最高的放在最前面。 列表不能太长 优化module.noParse happypack将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程 ParallelUglifyPluginuglfyjs是webpack内置的，但是在构建线上代码时会卡住，即是在进行代码压缩。压缩代码需要将代码解析成用object抽象表示的ast语法树，再去应用各种规则分析和处理ast，因此导致这个过程计算量很大，非常耗时 ParallelUglifyPlugin会开启多个子线程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程还是用uglfyjs压缩。 自动刷新 文件监听原理： 定时获取文件的最后编辑时间，每次存下最新的最后编辑时间，如果发现当前的获取的时间和最后一次保存的编辑时间不一致，就认为该文件发生了变化 watchOptions.poll用于控制定时时长，每秒检查多少次 当某个文件被判定为发生了变化时，并不会立刻告诉监听者，而是会先缓存起来，搜集一段时间后，再一次性告诉监听者。 watchOptions.aggregateTimeout 用于配置这个等待时间 自动刷新原理 控制浏览器自动刷新方法： 借助浏览器扩展去通过浏览器的提供的借口刷新，比如webstorm的liveedit 向要开发的网页中注入代理客户端的代码，通过客户端的去刷新页面 将要开发的网页装入一个iframe中，通过刷新iframe去看到最新效果 webpack通过devServer.inline控制是否向每个chunk中注入代理客户端，在开启inline时，devserver会向每个chunk注入代理客户端的代码，而项目中chunk有很多chunk，因此会导致构建缓慢。 启动项目时，可以通过执行命令webpack-dev-server。—inline false完成。那么就会采用第三种方式进行页面刷新。 模块热替换 原理 和自动刷新原理类似，都需要在开发的网页中注入一个代理客户端来连接devserver和网页。当子模块发生更新时，更新事件会一层层向上传递，直到有某层的文件接收了当前变化的模块，这时就会掉用callback函数去执行自定义的逻辑。如果事件一直往上抛，到最外层都没有事件接收他，那么会直接刷新页面。 优化 监听更少的文件，忽略nodemodules目录下的文件。 cdn加速 缓存问题 cdn一般会为资源开启很长时间的缓存，可能会导致最新的发布不能用 针对html入口文件，放到自己的服务器中，关闭自己服务器上的缓存，自己的服务器只提供html和数据接口 针对静态的js，css，图片等文件，开启cdn和缓存，每个文件带自己内容的hash值 使用 在output.publicPath设置js的地址 在css-loader.publicPath设置css导入的资源地址 在webplugin.stylepublicpath设置css文件的地址 压缩代码 js 使用 uglifyplugin和paralleugifyplugin（多线程）进行压缩 压缩es6 优点：对于一样的逻辑，es6代码量少于es5；js对es6的语法做了性能优化，例如针对const声明的变量有更快的读取速度。 使用uglifyes进行压缩 压缩css 使用cssnano进行压缩 tree shaking去除无用的死代码配置babel保留es6模块化语句，presets：modules：false 启动时带上—display-used- exports参数，指出哪些函数有用和无用。 启动时带上—optimize-minimize去除无用代码 配置reslove.mainfields，优先采用jsnext：main（第三方包打包出的es6模块） export default无法做tree shaking，因为导出的是一整个对象 提取公共代码 使用commonchunkplugin 分割代码按需加载 原则 1: 将整个网站划分成一个个小功能，再按照每个功能的相关程度将它们分成几类。 2: 将每一类合并为一个chunk，按需加载对应的chunk 3: 不要按需加载用户首次打开网站时需要看到的画面所对应的功能，将其放入执行入口所在的chunk中，以减少用户能感知的网页加载时间 4: 对于不依赖大量代码的功能点，例如依赖echart画图，将其进行按需加载 webpackChunkName：name import（&#x2F;* webpackChunkName：name *&#x2F; path）：为动态生成的chunk赋予一个名称，方便追踪和调试代码，若不指定名称，那么默认为[id].js 以path路径下的文件为入口重新生成一个chunk，当代码执行到import所在的语句时，才会去加载chunk对应生成的文件。import会返回一个promise，当文件加载成功时可以在promise的then方法获取对应的文件内容。 scope hoisting 实现原理 分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中。但前提是不能造成代码冗余，因此只有被引用了一次的模块才能被合并。 prepack 在保持运行结果一致的情况下，改变源码的运行逻辑，输出性能更好的js代码 工作流程： 1: 通过Babel将js源码解析成抽象语法树，以更细粒度地分析yuanma 2: prepack实现了一个js解释器，用于执行源码。借助这个解释器，prepack才能理解源码具体是如何执行的，并将执行过程中的结果返回到输出中。 使用prepack-webpack-plugin插件。 可视化打包结果 webpack-bundle- analyzer http://wepack.github.io/analyse","categories":["webpack"]},{"title":"【webpack】工作流程","path":"/2024/02/06/读书笔记/【webpack】工作流程/","content":"http://wepack.wuhaolin.cn/5-2输出文件分析.zip bundle.js能直接中浏览器运行是因为输出的文件中通过__webpack_require__定义了一个可以在浏览器执行的加载函数，模拟nodejs的require。 原本一个个独立的模块文件被合并到了一个单独的bundle.js的原因是浏览器不能像nodejs一样快速在本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。如果模块数量很多，那么加载时间会很长，因此将所有模块都存放到了数组中，执行一次网络加载。 流程概括初始化参数 从配置文件和shell语句中读取和合并参数，得出最终的参数 发生事件 event name desc 初始化参数 从配置文件和shell语句中读取合并参数，得出最终的参数，在这个过程中还会执行配置文件中的插件实例化语句 new Plugin（） 实例化compiler 用上一步得到的参数初始化compiler实例，compiler负责文件监听和启动编译，在compiler实例中包含了完整的webpack配置，全局只有一个compiler实例 加载插件 依次调用插件的apply方法，让插件可以监听后续的所有事件节点。同时向插件传入compiler实例的引用，以方便插件通过compiler调用webpack提供的api environment 开始应用nodejs风格的文件系统到complier对象，以方便后续的文件寻找和读取 entry-option 读取配置的entrys，为每个entry实例化一个对应的entrypath，为后面该entry的递归解析工作做准备 after-plugins 调用完所有的内置和配置的插件apply方法 after-resolvers 根据配置初始化resolver，resolver负责在文件系统中寻找指定路径的文件 编译阶段开始编译 用上一步得到的参数初始化compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译 确定入口 配置的entry找出所有的入口文件 编译模块从入口文件出发，调用所有的配置的loader对模块进行翻译，再找出模块依赖的模块，再递归本步骤直至所有的入口依赖的文件都经过本步骤的处理 完成编译模块使用loader翻译完所有的模块后，得到每个模块被翻译后的最终内容以及它们之间的依赖关系 发生事件 事件 解释 run 启动一次新的编译 watch-run 和run类似，但是是在监听模式下启动编译，可以获取是哪些文件发生变化导致重新启动编译 compile 告诉插件一次新的编译将要启动，同时会给插件带上compiler对象 compilation 当webpack以开发模式运行时，每当检测到文件的变化，便有一次新的Compilation被创建。一个Compilation对象包含了当前当模块资源，编译生成资源，变化的文件等，此对象也提供很多事件回调给插件进行扩展 make 一个新的Compilation创建完毕，即将从entry开始读取文件，根据文件当类型和配置的loader对文件进行编译，编译完成后再找出该文件依赖的文件，递归的编译解析 after-compile 一次Compilation执行完成 invalid 当遇到文件不存在，文件编译错误等异常时会触发该事件，该事件不会导致webpack退出 compilation阶段的事件 事件 说明 build-module 使用对应的loader去转换一个模块 normal- module- loader 在用loader转换完一个模块后，使用acorn解析转换后的内容，输出对应的ast，方便web pack对后面的代码进行分析 program 从配置的入口模块开始，分析其ast，当遇到require等导入其他模块的语句时，便将其加入依赖的模块列表中，同时对新找出的依赖模块递归分析，最终弄清所有模块的依赖关系 seal 所有模块及其依赖的模块都通过loader转换完成，依据依赖关系开始生成chunk 输出阶段输出资源根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中。 输出完成确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中 发生事件 事件 描述 should-emit 所有需要输出的文件已经生成，询问插件哪些文件需要输出，哪些不需要输出 emit 确定好要输出哪些文件后，执行文件输出，可以在此回调中获取和修改输出的内容 after-emit 文件输出完毕 done 成功完成一次完整的编译输出流程 failed 如果在编译和输出的流程中遇到异常，导致webpack退出，就会直接跳转到本步骤，插件在本事件中可以获取具体的错误原因 事件流webpack通过tapable来组织广播打包流程。webpack在运行时会广播事件，插件只需要监听它所关心的事件，就能加入这条线中，去改变打包的结果。 webpack的事件流机制保证了插件的有序性，使得整个系统的扩展性良好。事件流机制应用了观察者模式，和nodejs的eventemitter类似。compiler和compilation都继承至tapable，可以直接中在complier和compilation对象上广播和监听事件。","categories":["webpack"]},{"title":"【Web3】基本介绍","path":"/2024/02/06/读书笔记/【Web3】基本介绍/","content":"钱包作用用硬件或软件的方式，可以访问资金，与去中心化应用程序进行交互，充当无银行金融服务的网关、收集NFT、创建链上身份与社区，并提供比传统钱包更多的用途 组成条件 公钥：链接到自己可以发售和接收交易的地址 私钥：用于签署新交易并允许访问资金，必须保密 种子短语：用于生成多个私钥。作为根密钥，可以访问用户钱包中其他密钥和地址，也可以创建新的密钥 分类热钱包（软钱包）可以存储、发送、接收和查看代币，所以比其他类型的钱包更加方便 托管地：可以访问互联网和加密货币网络的设备上 实用性：最高 安全性：容易收到黑客攻击，因为连接到网络了 桌面钱包会被作为应用程序下载到电脑上，在本地运行被认为是可用的，最安全的热钱包类型 托管地：电脑 网络钱包允许通过浏览器界面进行交互和访问，无须在本地设备上下载或者安装任何内容具有与桌面钱包完全相同的功能，使用相同的区块链和区块浏览器来搜索区块和交易 托管地：其他人的计算机或者服务器上 手机钱包与桌面钱包类似，只是托管地是手机与桌面钱包相比，手机钱包的功能相对更简单一些 冷钱包无须连接到互联网，那么这就使得冷钱包是存储加密货币的更安全的替代方案，因为有物理介质可以离线存储密钥 安全性：抵抗黑客能力更强，对长期投资者来说很实用 硬件钱包使用随机生成器生成公钥和私钥的物理电子设备最适合长期投资和存储使用，因为它们不太容易获得 主要用例：确保未分配的、用于持续使用的大笔资金的安全性 安全性：最安全的存储方案之一，因为能够在设备中保存公钥和私钥，而无须借助任何互联网连接。这样对加密货币的访问是处于离线状态 纸钱包由物理打印出的区块链地址和私钥组成，到纸上。这些信息会被打印成二维码，可以通过扫描二维码来汇款 托管地：纸 缺点；只能一次性发送全部余额，不能多次发送部分 市面上主流钱包 以太坊钱包 metamask trust Wallet argent imToken 其他生态 phantom：Solana生态 keplr：Cosmos生态 polkadot：Polkadot生态 tezos：Temple生态 助记词由于私钥一般情况下，都非常冗长复杂，不适合记忆，为了方便使用，密码学家将其简化成了12或者24位不等的单词或者中文字符，简化之后的就被称为助记词 即： 助记词是密钥的另外一种形式 通过助记词可以获取相关的多个私钥，但是通过私钥无法获取助记词 区块链浏览器定义区块链浏览器是一种软件，它使用api和区块链节点从区块链中提取各种数据，然后使用数据库来排列搜索到的数据，并以可搜索的格式将数据呈现给用户 背景区块链钱包可以提供不同类型的数据，但仅限于与钱包管理的密钥相关的数据。区块链浏览器用于查看与在给定区块链的所有钱包上执行的交易相关的数据。特殊之处就是在于透明度，它允许用户检查智能合约地址的余额和支出，如当用户参数首次代币发行时。 作用 查看任何钱包地址的交易历史能够审计任何钱包地址并提高区块链的透明度 查看接收和更改地址可以查看交易接收地址、更改地址。将加密货币返回给支出者，以防输入值过多用于交易费用，提高了交易的透明度 查看当天最大的交易 查看内存池的状态可以查看区块链上未确认的交易及其详细信息 查看双花交易部门浏览器支持 查看孤立和陈旧区块孤立区块：挖掘之后没有附加到最长的区块链上，并且它们的父区块链是未知的 陈旧区块：已知父区块链，但未链接到已知最长链的区块 查看发现或开采特点区块的个人或矿池 查看创世区块 允许用户查看交易费用、区块链难度、哈希率和其他数据 优势 将加密货币发送给某人之前会检查钱包地址是否对区块链有效 检查加密货币是否已经发送给目标个人。所有者可以检查他们的钱包余额 可以帮助解释尚未通过或确认的交易出现的问题以及查看确认jieduan 帮助用户了解交易或Gas当前的成本，从而帮助计划未来的Gas支出 帮助用户了解某个组是不是挖掘交易的人，并有助于决定是否为未来的挖掘活动投入更多的计算资源 可以帮助正在开发钱包的人，如果它可以进行正常的工作（发送、接收、存储和加密货币） 与其他软件一起使用，可以证实数据和信息 工作流程 资源管理器首先使用节点接口提取给定区块链中的所有数据，一旦它导出数据，就会将其存储在可搜索的表格中 将收集最新的交易和区块，根据定义的可搜索类别进行排列。它为用户提供了一个界面用于搜索。在技术方面，资源管理器可以使用关系数据库、sql数据库和api 每个区块链节点都可以直接读取区块链上的数据，获取最新交易和挖掘区块等数据等详细信息，然后将其发送到数据库，其中数据以可搜索表格的形式排列，使得资源管理器可以快速使用这些数据。 大部分的区块链使用表格，每一行都有唯一的id或者键用于区分 域名系统在区块链中，域名系统和网络中的域名概念不同。区块链中，域名指向的是钱包地址，是一种身份的关联和映射，解决了ip或钱包地址过长的问题 ENS域名系统含义ens由两个以太坊智能合约组成：记录域名的ens注册表和将域名与机器的可读地址互相转换的解析器 获取在ens app上注册 DAS域名账户系统含义das是web3的去中心化身份认证系统，和ens类似，允许用户将个人域名绑定都适用所有链的人类可读地址。 预言机预言机充当区块链上的app接口，通过查询可以获取智能合约的相关信息。预言机也可以向真实世界发送数据 背景大多数区块链都有用于转移价值、启用协议操作或促进治理的本地加密货币，一些区块链支持智能合约，而智能合约可以在没有第三方的情况下执行，并且可以设计为执行几乎任何可以想象得到的合约。 区块链和链上智能合约需要一种方法来利用外部的链下数据，以便智能合约执行影响现实世界的app，因此预言机就需要被用到 分类 软件预言机 提供来自网站、服务器或数据库等数字源的数据。可以提供实时信息 硬件预言机 提供来自现实世界的数据，可以传递和中继来自项目运动传感器 集中式预言机 它由单个实体控制，并充当智能合约的唯一数据提供者。它要求合同参与者对一个实体给予极大的信任；它还代表单点故障，这可能会威胁到智能合约的安全性，如果预言机被破坏，智能合约也会被破坏。智能合约的准确性和有效性在很大程度上取决于所提供数据的质量，因此预言机对智能合约有很大的权利。 预言机问题：预言机可以使智能合约在去信任方之间执行，但当他变得过度中心化时，可能会有它试图成为中间人的风险。 去中心化预言机 去中心化预言机试图实现依赖因果关系而不是个人关系的去信任和确定性结果。它以与区块链网络相同的方式实现这些结果，在许多网络参与者之间分配信任。通过利用许多不同的数据源并实施不受单个实体控制的预言机系统，去中心化的预言机网络可能成为为智能合约提供更高级别的安全性和公平性。 实例Chainlink","categories":["Defi"]},{"title":"【Web3】去中心化存储协议","path":"/2024/02/06/读书笔记/【Web3】去中心化存储协议/","content":"IPFS定义ipfs星际文件系统是一种点对点的文件的共享协议。ipfs用于存储和访问文件、网站、app和数据，使用内容寻址来识别连接所有计算设备的全局命名空间中的每个文件。ipfs不是通过位置，而是通过文件内容进行文件寻址的。为了识别内容，使用内容的加密hash值。 ifps允许用户通过对等文件共享以分散的方式托管和接收内容，那么这样表示用户操作员拥有一部份整体数据，从而创建了一个强大的文件存储和共享系统。网络中的任何用户都可以简单的通过文件的内容地址来提供文件，其他用户可以通过分布式hash表（dht）定位并请求任何拥有该内容的人。 工作流程组成组件： 分布式哈希表（dht dht使用散列函数来计算索引，用户可以从中找到需要的值。即数据分布在计算机网络中，并进行协调，实现节点的分布式间的高效访问和查找。 优势：去中心化程度高、容错性能、可扩展性高 bitTorrent 是一种文件共享系统，能够通过数据交换协议来协调节点间的数据传输。但仅适用于Torrent系统。而ipfs提供bitswap，是该协议的更加通用版本 merkle dag 它是merkle树和有向无环图（dag）的组合，merkle树负责确保p2p网络上交换的数据块是正确的，并且绝对不会发生变化。 验证是使用加密散列函数组织数据块完成的，该函数接受输入并计算与该输入对应的唯一散列，以确保产生的散列比较简单，但很难通过散列猜测输入 dag是一种没有环的拓扑信息序列进行建模的方法。家谱是dag的基本表示。merkle dag本质上是一种数据结构，其中hash值用于引用数据块和对象。 ipfs的主要原理是在广义merkle dag上所有数据进行建模 sfs：自认证文件系统 sfs是一种分布式文件系统，不需要特殊权限即可交换数据。提供给用户的数据仅提供文件名进行身份验证，该文件名由服务器签名，即用户可以通过本地存储的透明性安全的访问远程内容 优势去中心化的ifps有一个主要目标：可以从不由一个组织管理的多个位置下载一个文件 支持强大的互联网。当无法访问服务器时，可以从其他人检索到相同的信息 增加审查内容的难度。因为ipfs上的文件可能来自多个位置 arweave定义arweave可以看作为使用区块链开安全、永久地存储全球信息的去中心化协议。 arweave的p2p协议允许硬盘驱动器中拥有大存储空间的各种用户（节点）连接到arweave网络，并为他人存储数据，然后ar网络会奖励这些节点。当存储在特定系统中的数据逐渐增加，共识需要的散列量减少，从而产生更具有成本效益的数据存储。 工作流程arweave包含blokcweave和permaweb blockweave blockweave除了存储交易信息外，还存储每个区块的数据信息。blockweave上的每个块都引用其前一个块，前一个块被附加到一个随机选择到块上，即召回块。 arweave协议通过部署一种名为SPoRA的全新共识机制启用此架构，这种共识机制奖励网络中的参与节点存储arweare的所有交易历史。 例如如果想管理其中一个节点，要获取区块奖励，那么必须向blockweave证明可以完全访问前一个区块的数据以及一些随机选择的召回块。如果无权访问召回块，那么就知道没有将所有的交易数据全部放在arweave区块链上，因此会拒绝奖励。 permaweb 建立在arweave区块链上的去中心化网络，存储所有arweave dapps的地方。arweave使用http，用permaweb可以与网络进行交互 特点 使用方便 技术细节都放在后端；使用扩展程序保存的页面可以由去中心化的网络中的其他用户查看和共享 不变性 以用户和开发人员为中心的精神 它奖励并鼓励开发人员提高所构建的app的质量。推动开发人员并建立和参与使用其dapp的社区。 优缺点 优点 数据不会被丢失 每秒可以处理超5k笔交易 ar代币有相当稳定的历史价格走势。 缺点 解决可扩展性问题的协议可能不被人相信 icp协议：去中心化计算机定义icp是一种完善的区块链开发方案的聚合，使在线开发人员能够不再依赖商业云服务、数据库服务器、web服务器、dns服务、防火墙以及大型科技企业的专有应用程序编程接口。开发人员使用icp将可以自由地构建和部署安全、自主和防篡改的计算单元，这种计算单元类似于docker，它几乎可以完成任何事情。 icp是基于智能合约演变来的，它以分布式、复制的方式运行软件，同时还能捕获该软件程序状态的完整技术。用户通过互联网身份与这些容器进行交互，这是一种匿名区块链身份验证框架，将在线活动与物理技术设备相关联 重要性 icp作为一种区块链技术，仍然具有民主精神，参与者可以通过质押icp投票决定icp的未来。 icp设计初衷是保护用户的数字身份，防止其被广告商、黑客和其他恶意软件滥用。icp通过消除用户的互联网身份来实现匿名，通过区块链身份验证框架确保用户拥有自己的数据，这些数据由区块链备份，并只有持有对应备份的私钥用户本人才能访问。如果用户任何物理设备被入侵，那么可以使用存储在安全位置的助记词快速恢复其互联网身份 icp在分散、集成的生态系统中重新构建了智能合约和软件，同步服务可以最好的满足用户需求。 icp提出了一种新的价值模型，通过将加密货币与法定货币的有效用标记化相关联来补充比特币，而不会存在集中管理的弱点。icp在模型上是比特币的升级版本，具有直接标记实用程序的优势，而没有法定货币集中管理的劣势。icp允许使用网络神经（nns）参与网络治理，并且可以重新启动以运行分散的app。 icp承诺将与比特币进行深度绑定，并和比特币的价值一起成长。icp的目的是准备与现有的加密代币和web3结构建立共生关系，以连接和授权它们。 icp的区块链是环保的。执行交易或者其他日常任务时的电力消耗与发送邮件的电力消耗基本等同。 工作流程icp有为计算提供动力的循环机制，icp代币用于铸造新的周期，这些周期由icp子网络燃烧以进行计算 在icp区块链上，稳定的周期使基于icp的软件开发成本可预测且始终处于较低水平。icp循环可以发送到icp容器以供其以后在执行计算或者存储数据时使用。icp软件可以用任何可以编译为webassembly的编程语言编写，以部署在icp的区块链上。 icp可以与环境分离，并与其他容器或用户交互以执行计算和智能合约代码。","categories":["Defi"]},{"title":"【Web3】公链","path":"/2024/02/06/读书笔记/【Web3】公链/","content":"阶段第一阶段：2008-2015以早期比特币之类的数字货币公链为主，可以理解为一种“公共账本” 第二阶段：2015～以太坊公链的出现为开端，标志着底层公链时代，智能合约被提出。 主流的公链有：比特币链、以太坊链、币安链、瑞波链、艾达链、索拉纳链、波卡链、雪崩链、波场链、马蹄链 以太坊EVM：以太坊虚拟机建立在以太坊上的抽象虚拟机，可以使DApps之间彼此隔离，并且与主链分离。即它是一个虚拟的运行环境，以太坊智能合约的运行是建立在此基础上的。 特点可扩展、可编程、安全和去中心化 以太币智能合约本质是一段小的代码程序，那么运行它的载体上通过以太坊网络的矿工进行维护的。给予矿工以太币-Gas费，因此智能合约想运行在以太坊公链上，那么需要支付Gas费，当无法支付时，那么程序也就停止了。 DApps 含义 是一种去中心化的数字应用程序，存在并运行于计算机的区块链或点对点(P2P)网络上，而不是单个计算机。 DApps不在单一机构的权限和控制范围内，通常说建立在以太坊平台上，可以被开发为用于各种目的的App，包括游戏、社交App等。 App权限普通应用程序中，其开发者们拥有对这个app及其工作的完全权限。 而DApps不同，它在公链上运行，不受任何单一机构的控制和干扰，例如在以太坊上发布运行了一个DApp，若有人通过这个智能合约购买了一个商品，智能合约被执行，任何人都无法删除这个合约的执行信息。 优劣 优势：保护用户的隐私，使用去中心化的dapp，用户无须提交个人信息即可使用app；dapp使用智能合约完成交易，无须依赖中间机构 劣势：执行智能合约需要Gas，因此费用一般较贵；有效扩展在需要大量计算以及网络过载导致网络拥堵的时候容易存在问题 Cosmos生态含义cosmos也被称为区块链互联网，是一个由独立但可以互相操作的区块链组成的去中心化网络，用户可以在无须许可的交换信息和代币 Cosmos中“区域”的独立区块链由基于拜占庭容错的权益证明Tendermint共识算法支持。拜占庭容错共识算法允许网络达成共识，即使某些节点发生故障或者恶意行为 目的提供工具帮助开发人员为各种用例快速构建独立的区块链，使得网络中的区块链可以互相通信，从而解决区块链面料的比如可扩展性、可用性和治理问题等。 加密货币：ATOMATOM是Cosmos背后的驱动力。 功能： 维护网络共识 通过基于激励的验证节点进行质押 减少垃圾邮件作为支付Gas费的媒介 提供投票机制，通过Cosmos治理提案提出网络修正 用途 通过权益证明共识机制的运行 验证者质押或者锁定他们的ATOM并运行专门的软件，该软件通过新区块和验证交易维护Cosmos网络 持有者可以选择将自己的ATOM代币委托给验证者，允许获得一部份质押奖励。 实现 Tendermint Core BFT共识机制 Tendermint主要成立目的是解决工作量证明共识算法的速度慢、可扩展性差以及高性能耗问题 它提供即使、可证明安全的移动客户端支付验证的方法。在设计上，它是不允许分叉的，所以移动钱包可以实时接收交易确认，从而在手机上实现信任的支付方式 它需要一种“验证人”，类似于比特币的矿工，是一种专门用于提交区块的安全机器(和矿工需要大量的Gas一样，需要消耗大量的代币)。验证人可以向非验证人租借代币，并承诺收益，但验证人被攻击或者违反协议规定，那么就会有一定的惩罚，比如削减代币 可互操作 Cosmos Hub是一个及其强大的去中心化区块链网络，其结构和治理允许网络参与者保持冷静。ATOM作为一种质押机构用于增强安全性、达成共识、提高运营效率 优势 互操作性：Cosmos协议广泛支持现在的主流公链，而不是像EVM或者非EVM局限在自己的代码框架体系里，它是一种去中心化的交易中心 可扩展性：对于传统公链，每笔交易都需要Gas费，而且每秒事务处理量往往只能达到每秒几笔的规模，而Cosmos基于自身协议的前瞻性，每秒可以处理几千笔 Avalanche链定义采用了一种独特的方式，在其主要平台中使用三条独立的区块链：交易链(X-Chain)、合约链(C-Chain)、平台链(P-Chain)。 Avalanche链最重要的突破之一是雪崩协议(Avalanche Consensus)，它是使用验证者重复的子抽样投票来快速达成共识的用户负担得起的方法。 Avalanche链还将子网作为一种新的水平扩展方法，允许创建可定制的、可互操作的区块链，子网没有数量限制 区块链分类 交易链：X链负责AVAX或者其他数字资产的创建和交易 合约链：C链 可以为DApps创建智能合约。该链实现了以太坊虚拟机下，支持兼容EVM的DApps。合约链使用Snowman共识协议，它是Avalanche共识协议的修订版 平台链：P链 用于协调验证者和子网。使用Snowman共识协议 解决问题 可扩展性差和去中心化弱 传统区块链活动增加的网络可能会迅速堵塞，例如比特币，在网络拥堵期间，交易有时候需要数小时或者几天才能完成 那么解决方法之一就是让网络更加集中，让更少的人有更多的权限来验证网络活动，从而提高交易速度。但由于去中心化是区块链中非常重要的特点 Avalanche共识协议不需要领导者达成共识，例如Pow、PoS(权益证明)或者DPoS(委托协议证明)。因此中不牺牲可扩展性的情况下，提高了Avalanche网络的去中心化程度 交易费用高 Avalanche共识协议不需要领导者达成共识 互操作性不佳 Avalanche链提供带有子网的解决方案，共享主网络的安全性、速度和兼容性的自定义应用程序特定区块链 特点 共识机制 Avalanche使用的是雪崩共识，虽然并不是唯一具有新颖共识机制的区块链 交易速度和最终确定 权利下放 可互操作的区块链 可互操作区块链的数量可能是无限的 Solana链（非EVM定义基于RUST语言，原生加密货币SOL用于支付交易费用和质押。历史证明机制(PoH)使其能够高度可扩展且搞笑的网络 Solana链是一个加密计算平台，旨在不牺牲去中心化的情况下实现高交易速度 功能 PoH机制 该机制可以提供数字记录，确认网络上任何时间点都发生过什么事情。可以呈现为一个加密时钟，为每笔交易提供时间戳以及添加简单的数据结构 PoH机制依赖于使用BFT算法的交易时间权益证明(PoS)共识机制，BFT使用同步时钟的优势，可以在不产生任何大量事务延迟或消息传递开销的情况下达成共识，保证网络安全和运行，并充当验证交易的附加工具 PoH可以被视为一种高频可验证延迟函数(VDF)，VDF是一种三重函数(设置、评估、验证)，可以产生独特且可靠的输出。VDF通过证明区块生产者已经等待足够长的时间，让网络继续前进来维持网络中的秩序 Turbine Turbine是网络上的块传播协议，它支持更轻松地将数据传输到区块链节点，通过将数据分解为更小的数据包来实现高效的数据传输。因此Solana区块链可以解决与带宽有关的问题，提高整体容量，加快交易结算速度 湾流(Gulf Stream) 作用是承担着将事务缓存转发到网络边缘的，因此验证者可以确保提前执行交易，减少确认时间。湾流有助于更快的切换领导者，同时减少来自不同未确认交易池的验证者的内存压力 Sea Level 海平面是一个超并行事务处理引擎，用于在各种SSD和GPU之间进行性能扩展 Pipeline 用于优化验证的事务处理单元，该过程设计将输入数据流分配给不同的硬件组件，因此可以支持在网络中的不同节点上更快地验证和复制交易信息 Cloudbreak 它是Solana链的横向扩展帐户数据库，有助于在Solana网络上实现所需的可扩展性。Cloudbreak是一种数据结构，是跨网络并发读写操作的理想选择 Archivers 存档器 散列算法：SHA-256","categories":["Defi"]},{"title":"【Web3】二层网络","path":"/2024/02/06/读书笔记/【Web3】二层网络/","content":"二层网络定义指构建在现有区块链系统之上的二级框架或者协议，这些协议的主要目的是解决主要加密货币网络面临的交易速度低和扩展困难的问题 “二层”指的是针对区块链可扩展性问题提出的多种解决方案。例如早期的二层解决方案：比特币闪电网络和以太坊等离子体，虽然受限于自身工作机制和特殊性，但这两种解决方案都尽量为区块链系统提供更高的吞吐量 二层网络技术侧链它是一条平行于主链的独立运行的链。不依赖于主链的安全策略，有自己独立的安全策略。 状态通道只记录出入该通道的某一瞬间的交易。但其安全性不足，因为需要保证状态通道的运营者是可以信任的，否则投入就会有不安全性 卷叠把一切复杂的交易都交给二层网络，复杂的数据都交给卷叠处理，处理完成后只返回数据摘要或处理结果。这样对性能有一定的提升。 ZK-RollupsZK-Rollups协议促进了交易者和中继者的交互。 工作流程 交易者创建并将其交易数据广播到网络，此信息包括索引的双方地址、交易价值、网络费用和仅使用一次的数字。利用索引地址减少资源处理，交易价值产生存款和取款金额。然后智能合约将地址记录到一个Merkle树，并将交易值记录到另一个Merkle树 中继器负责收集创建汇总的事务。中继器生成一个简洁的非交互零知识论证证明，用于比较每笔交易前后的区块链状态（钱包余额）。由此产生的变化以可验证的方式散列并到达主链。 Optimistic Rollups和ZK-Rollups类似，但ORs仅向主链发布最少的信息，仅在欺诈案件中生成证明。 工作流程 当用户将交易发送到链外ORs时，聚合器注册并提交欺诈证明 聚合器在本地部署交易以生成新的智能合约。计算新的状态根，聚合器将交易和状态根发送回主链 如果用户认为聚合器返回了欺诈状态根，包括无效交易，他们可以质疑聚合器。用户可以通过发布正确的状态根和验证它所需的Merkle证明在注册这一挑战。对于违规的聚合器，以及任何建立在无效区块之上的聚合器，其保证金被削减，这些收益流向报告用户 一旦识别出无效块并完成欺诈证明，二层链就会回滚，并在前一个非欺诈块处恢复 优劣 劣势 无效状态：OP允许存在无效的区块链状态。因此，在提交欺诈证明前，可能会存在无效状态 安全性：由于其基于博弈论模型，OP可能更容易受到攻击，因为用户可以参与报告欺诈 可扩展性：随着交易规模的扩大，在某些情况下，OP可能需要更多的主链计算资源，从而导致更高的成本。 Arbitrum是解决以太坊网络拥塞和高费用问题的解决方案之一 工作流程Arbitrum生态系统中包含四个角色：验证者、虚拟机、密钥和管理器。 Arbitrum基于简单的加密货币设计，其中各方可以将智能合约实现为对合约规则进行编码的VM，它是中Arbitrum虚拟机架构上运行的程序。虚拟机的一组管理器由VM的设计者指定。 基于Arbitrum协议，任何一个管理者都可以强制VM根据VM的代码运行，与VM的结果有利害关系的各方可以选择各自信任的人代表他们这样做或者直接担任管理者。VM的状态可以通过依赖管理者器以及降低验证者的成本来提升，验证者只需跟踪虚拟机状态的hash值，而不是整个状态。","categories":["Defi"]},{"title":"【Web3】SocialFi","path":"/2024/02/06/读书笔记/【Web3】SocialFi/","content":"SocialFi汇集了社交媒体和defi的原则，它提供了一种去中心化的方法来创建、管理和存储社交媒体几其参与者生产的内容。 在SocialFi的核心，应用程序是内容创建者、影响者和参与者，它们希望更好的控制自己的数据，保障言论自由以及通过参与社交媒体获利。货币化通常发生在加密货币中，而身份管理和数字所有权则由nft驱动。 构建模块货币化SocialFi应用程序通过使用社交代币或者应用内实用代币，这些代币不仅可以在应用程序级别创建，而且可以在用户级别创建，创作者可以通过社交代币管理自己的经济。 模型的基本设计原则： 只有那些持有创作者社交代币的人才能参与他们的帖子， 如果想引起影响者的注意，持有最多数量的社交代币时，消息回复会出现在回复页面首页 创作者和影响者可以设置阈值，允许拥有超过一定数量社交代币的追随者直接向他们发送消息 当用户想要通过点赞或者分享与某人进行互动时，需要花钱。 审查与言论自由SocialFi平台通过标记链上数据进行去中心化管理。SocialFi平台所有可公开查看的帖子都在链上，因此，这些链上数据可供规则引擎根据主题和所用词的性质来解析和快速标记帖子。 每个单独的节点都可以选择阻止一些标签并与其他标签互动。如果一个节点选择参与和认可一个有害帖子时，它将收到法律起诉。因此，在网络中必须允许非中央机构或中央组织内的小团体做出选择，控制器和责任在于个人。 数字所有权和身份如果用户想创建一个SocialFi资料，可以使用自己的nft作为个人头像，并通过连接他们的钱包来确认自己的nft所有权。 SocialFi平台中的nft为创作者提供分发功能来广播他们的作品。","categories":["Defi"]},{"title":"【Web3】NFT","path":"/2024/02/06/读书笔记/【Web3】NFT/","content":"定义nft是以数字形式表示的加密货币资产，每个nft都是独一无二的，这样有形资产和无形资产都能够被标记。即nft指可以投资于有价值的东西，而无须实际拥有或者存储它们，因此，在公开市场上买卖nft变得非常容易。 每个nft都可以通过唯一的交易hash值识别，即没有两个nft是完全一致的。 工作流程冷现金是属于同质化资产（可替换，实际价值不变），而nft是一种非同质化资产，即无法相互转换，转换之后价值也不能完全一致，因为每个代币都是唯一的。 区块链协议 所有最好的nft都托管在区块链协议上，许多nft的创建者更喜欢以太坊区块链，尤其是因为它支持erc-721代币。即以太坊区块链这个特定子集非常适合nft，因为每个erc-721代币都是独一无二的。 以太坊铸币 铸币指的是创建尚未存在的新nft的过程。即当购买nft时，购买的是已经由其他人创建的数字资产。如果希望获取的是第一次被创建的nft，那么可以通过以太坊或者币安链等区块链网络铸造nft，这样nft可以验证你是否是真正的所属者。 类型分割式nft以类似于股权的形式去分配一个nft，每个拥有的人都有可以获取一定比例的财产。 但是这个功能目前还未完全定型，处于探索状态。 实物不动产实物房地产是用nft表示的资产的完美示例，房产和nft都是独一无二的。 常见用例是部份所有权，例如房地产开发商想向零售客户开放投资机会，那么开发商可以让nft与一定比例的所有权相关联，然后在公开市场上发行nft 元宇宙中的虚拟房地产CryptoPunks和其他数字收藏品CryptoPunks是2007年创建的1k个数字图像的集合，每个CryptoPunks都是独一无二的，并由nft支持。 体育nft有些体育品牌正在出售来自关键游戏赛事的视频剪辑的所有权或者比赛时的个别物品 游戏nft好处 适合内容创作者 保护知识产权 价值存储 现在所被创造出来的nft都是有价值的，因为铸币nft是需要有价值的东西才能被铸造。 市场较大 nft可用抵押品 nft与加密货币 相同点 以数字形式表示 构建和存储在区块链中 不同点 nft是非同质化货币，而加密货币是同质化产品。 每个nft都是独一无二的，价值也是独一无二的 CryptoPunks定义CryptoPunks是larva labs创建，是一个拥有1w个数字图像的系列，在以太坊区块链上被标记为nft。 nft实际上是对数字项目的所有权契约，持有CryptoPunks nft表示是该独一无二像素头像的唯一所有者。 BAYC定义BAYC是在以太坊区块链上铸造的一系列的nft头像，由1k枚nft组成，样式设计为以太坊区块链的猿猴。","categories":["Defi"]},{"title":"【Web3】GameFi","path":"/2024/02/06/读书笔记/【Web3】GameFi/","content":"定义GameFi是游戏和金融的组合，涉及到区块链游戏，对玩家提供经济激励。奖励包含游戏内部的奖励或者以nft为载体的奖励。 示例 Decentraland（MANA和LAND代币）、 the sandbox（结合DAO和NFT） axie infinity（AXS代币） 前期需要准备3个axie nft作为起始，后续可以通过此游戏赚取回报获取slp代币，可以兑换为金钱 Gala Games（以GALA为代币） 将自己定位为一个游戏区块链生态孵化者，经济驱动剂是根据以太坊区块链上的erc-20标准创建的gala代币，兼容币安智能链。 其生态系统包含游戏、游戏发布平台、nft市场、游戏云托管服务和平台自身的代币经济学。 玩家可以通过特定的投票机制决定gala games平台应该添加哪些游戏。 Enjin（是生态系统范围的解决方案，旨在通过对游戏内资产进行代币化并注入项目的原生代币ENJ） 基础设施包含GraphQL和可信云。由于enjin允许开发人员用sdk和api以便根据需求访问响应功能，因此它采用graphql简化访问资源的方式，促进了虚拟世界和智能合约区块链之间的交互。而可信云允许enjin网络sdk和api的游戏与以太坊区块链互联 游戏公会YGGygg是专注于区块链p2p游戏的游戏公会，投资nft资产并将全球的区块链游玩家连接到一起的社区。 目标是建立一个属于玩家和投资者的网络，帮助彼此在nft游戏领域起步和成长。 定义投资于区块链游戏中使用nft的dao？游戏包含较为广义的元宇宙，具有基于区块链的数字世界中的众多元素，包括数字土地&#x2F;货币等。 运行结合了defi和nft，在以太坊区块链上创建了一种元宇宙经济。 ygg由多个subDAO（依附于DAO的较小DAO）组成，而这些subdao由来自特定nft游戏或地理位置的玩家群体组成。每个subdao都有自己的一套规则，用于管理各自的p2e游戏的活动和资产。 在ygg上，所有nft和数字资产都存储于社区控制的ygg金库中，金库为每个subdao提供nft，包括多个区块链游戏的p2e资产。 代币ygg代币是一种赋予持有人对ygg dao的治理权利的erc-20代币。ygg代币可以用于支付网络上的服务费用，也可以在质押后在ygg收益池中获取奖励，或用于解锁ygg discord频道上的独家内容。此外，ygg代币持有者还可以提交提案，并对公会的技术、产品、项目、代币分配和整体治理结构等决策进行投票，最终在dao中得到实施的获胜建议将获得ygg代币奖励。 dappradar 常用信息平台该平台通过包括以太坊、eos和ont在内的20多个协议跟踪1w+dapps，使用户可以分析和比较各自dapps。 定义网站自称为为全球用户带来了关于去中心化应用程序的高质量、准确的见解，迅速成为值得信赖的行业信息来源；发现dapps的起点，托管来自30多个协议的9k个dapps；能提供全面的nft估值和投资组合管理，并在数据主导、可操作的行业报告方面处于领先地位。 它的代币RADAR具有多种功能：持有人可以质押radar以赚取被动收入；是一种治理代币，允许持有者对生态系统的未来发展进行投票；用户可以获得对特定功能和见解的独占访问权限。","categories":["Defi"]},{"title":"【Web3】DAO","path":"/2024/02/06/读书笔记/【Web3】Defi/","content":"defi是“去中心化金融”的缩写，是加密货币或者区块链中各种金融app的总称。 defi从区块链中获取灵感。区块链是数字货币背后的技术，它允许多个实体持有交易历史的副本，这意味着它不受单一的中央来源控制。 主流的defi应用 去中心化交易所（dex）。它帮助用户将货币兑换为其他货币，它直接连接用户，因此他们可以直接交易加密货币，而无须信任中介机构的资金 稳定币：一种与加密货币以外的资产挂钩并具有稳定价格的加密货币 借贷平台：这些平台使用智能合约来代替中间管理借贷的银行等中介机构 跨链比特币（wbtc）。将比特币发送到以太坊网络的方式，因此比特币可以直接在以太坊的defi系统中使用。wbtc允许用户通过在上述去中心化借出的btc赚取利息。 预测市场。投注未来事件结果的市场。defi版本的预测市场目标是提供相同的功能但没有中介机构。 dex：去中心化交易所dex是一个点对点市场，交易直接发生在加密交易者之间。处理加密货币之间的交易 工作流程通过cex（中心化交易所），可以将加密货币与法定货币之间互换。这些所有交易都是由交易所自己通过“订单薄”处理的，该订单薄根据当前的买卖订单确定特定加密货币的价格。而dex是不允许法定与加密货币之间的交易。 dex只是一种智能合约，它通过算法确定各种加密货币的价格，并促进流动性池（投资者锁定资金以换取类似的利息奖励来促进交易。 cex的交易记录在该交易所的内部数据库中，而dex的交易直接在区块链上结算 优缺点 优点 种类繁多。dex几乎提供了无限的代币种类 降低黑客风险。由于dex交易中的所有资金都存储在交易者自己的钱包中，因此理论上它们不太容易受到黑客攻击。dex还降低了“交易对手风险”（违约的可能性） 匿名性。使用主流的dex不需要个人信息 缺点 需要用户做大量的前期研究准备，不能指望dex本身提供很多帮助。在dex中进行复杂交易需要一些专业知识 智能合约漏洞。任何defi协议的安全性都取决于为其提供支持的智能合约，而合约代码可能存在可利用的漏洞。 风险更高的代币。dex上面存在未经审查的代币 案例uniswap 稳定币稳定币是一种储备资产挂钩的数字货币，旨在降低相对于比特币等非挂钩加密货币的波动性。 常用的稳定币包括USDT、USDC、DAI等 DAIdai是一种加密资产，试图通过将其他加密资产锁定在合约中与美元保持1:1的价值关系。dai是一种名为maker协议的开源软件的产品，运行在以太坊区块链之上的dapp。dai保持其价值的方式是使用以ETH计价的抵押债务。抵押债务为贷方提供了一种使用他们拥有的资产获得贷款的方式。 maker协议通过以太坊运行的智能合约，使借款人能锁定ETH和其他加密资产，从而对其进行抵押，以便贷款的形式生成新的dai。如果借款人想收回抵押的eth，必须将dai返回给协议并且支付费用，如果发生清算，maker协议将使用基于市场的内部拍卖机制获取抵押品并出售。 工作流程dai是一种由其他加密货币抵押的加密资产。如果用户想获取dai，那么可以在交易所花费eth购买等值的dai，也可以使用maker协议抵押eth和其他资产。 抵押债务头寸（cdp）是maker上的智能合约，用户可以利用它来锁定其抵押资产（eth或bat）并生成dai。cdp可以视为存储抵押品的安全保险库。dai一般会被超额抵押，即所需的存款金额通常要高于dai的价值。 借贷平台借贷市场将借款人与加密货币的贷方联系起来。主流平台Compound允许用户借用加密货币或者提供自己的钱款，用户可以通过借款获取利息。Compound通过算法设置利率，因此如果借入加密货币的需求更高，利率将被推高。 defi借贷是基于抵押品的。 Compound它是建立在以太坊上的可公开访问的智能合约系统，允许借款人通过将其加密资产锁定到协议中来获取贷款和为贷方提供钱款。借款人和贷款人支付和收取的利率由每种加密货币的供求关系决定。每个区块的开采都会产生利率，贷款可随时还款，锁定资产可以随时提现。 原生代币是cToken，它允许用户从他们的钱中赚取利息，也能在其他应用程序转移、交易和使用 流动性质押质押是赚取资产被动收入的一种方式，同时可以支持区块链网络的安全和运营。流动性质押协议提供与常规pos质押相同的好处，减少了潜在的缺点。 流动性质押协议处于加密货币质押经济的最前沿，改变了defi行业的流动性准入。流动质押的优势之一就是能够在互动和使用资产的同时获取奖励，流动性质押协议为借贷协议和单产农业等活动提供可基础。 质押将加密资产锁定在协议中以获取回报的过程。通过将闲置资产投入使用，抵押加密货币是赚取被动收入的一种方式。质押协议可以协助pos共识机制，该机制促进关于区块链交易有效性的网络协议。因此，与比特币等pow区块链相比，降低可能源需求。 质押在一定时期内无法使用资金。 流动性质押锁定资金以赚取奖励的同时仍然可以使用资金的方式。 流动性质押运作用户有一个ETH，将eth放入流动质押协议中，然后会收到一个价值等值的stETH（质押的eth）作为回报。 该用户将从协议中保留的原始eth存款中获取奖励。为了获取被抵押的eth，需要一个stETH才能将其兑换回来。 流动质押优点 高产农业 流动性质押是收益农业活动的基本基石。收益农业是指交易者将资金锁定在一个协议中并收到这些资金的打包或者代币化版本。 加密贷款 快速存取资金 缺点 有风险 预测市场预测市场就是可以买卖预测的市场，即分享事件的结果。 预测市场是利用群体智慧来进行的，那么由于defi是一个去中心化的市场，普通民众也能参与，更加自由。 实例：Augur、Gnosis","categories":["Defi"]},{"title":"【Web3】DAO","path":"/2024/02/06/读书笔记/【Web3】DAO/","content":"DAO是一种由社区主导的“公司”，即去中心化的自治组织，它完全d是透明和自主的，由智能合约制定基本规则，执行商定的决定，并且在任何时候，提案、投票甚至代码都是可以公开审计的。 DAO完全由个人成员管理，他们共同决定项目未来的走向。 框架的特点之一就是激励措施的一致性，鼓励直言不讳，并且只批准符合协议本身最大利益的提案，同时符合他们个人的最大利益。 工作流程DAO的规则是由社区成员的核心团队通过使用智能合约建立的，这些智能合约奠定了DAO运行的基本框架，他们是高度可见的、可验证和可公开审计的，因此任何潜在的成员都可以充分了解协议在每一步的运作方式。 当规则被正式写入区块链，下一步就是弄清楚如何获得资金以及如何将其赋予治理。通常通过发行代币实现，协议通过发行代币来筹集资金并填补DAO的金库。作为法定货币的回报，代币持有者被赋予一定的投票权，通常与他们的持股数成正比，一旦资金筹集完成，DAO就可以进行部署了。 DAO部署完成投入使用后，除了通过成员投票达成共识外，不能再通过任何其他方式对其进行修改。 某些情况下，代币持有者可以投票决定在他们之间分配协议收取的部份费用（例如uniswap） 协议DAO目的是为了帮助构建协议而存在的协议体。 MarkerDAOMarkerDAO是协议DAO的一个典型示例。它是在以太坊区块链上开发借贷、储蓄和稳定加密货币技术的组织。即它是一个建立在以太坊上的DAO，允许在不需要中间人的情况下借贷加密资产，MarkerDAO由管理借贷的智能合约服务以及两种货币（DAI和MKR）组成，以规范贷款的价值。 MarkerDAO它创建了一个协议，允许任何拥有MarkerDAO钱包的人以DAI稳定币的形式借钱给他人。通过MarkerDAO的智能合约中锁定一些eth，用户可以创建一定数量的dai，锁定的eth越多，可以创建的dai越多。当用户需要解锁作为dai贷款抵押品的eth时，只需要偿还贷款和相关费用。 当贷款的抵押品价值降至某个点以下时，即eth的价格已经远远低于借入的dai数量，那么这个时候贷款就会被清算。清算和清算威胁通过防止人们借贷过多来保持系统稳定。如果“清算威胁”使系统保持诚实，那么mkr代币持有者是最后的贷款人。当eth价格崩盘并且一次清算太多贷款时，mkr被创建并出售以偿还贷款。同时，费用必须以mkr支付，清算罚款用于回购mkr，这些mkr会被烧毁或销毁。理论上，mkr应该始终有足够的价值来支持清算贷款，dai、mkr和eth作为一种自动制衡系统运行，两两之间相互抵消，以保持系统稳定和去中心化。 慈善DAO（grant dao社区捐赠资金并使用dao投票决定如何以治理提案的形式将资金分配给各种贡献者。grant dao最初的治理是通过不可转让的股份进行的，意味着成员参与的主要动机是产生社会效益而非财务回报。 Moloch DAOMoloch DAO为公共产品项目提供资金以改善以太坊生态系统。 目的改善和推动以太坊生态系统的项目提供资金。 它由成员决定哪些项目可以获得资助。它将区块链技术视为一种公共产品，即每个人都可以从中收益并应该平等的获得东西。 Gitcoin开发人员和编码人员可以在该平台获得报酬，以使用各种编程语言开发开源软件。用户可以向gitcoin平台提交自己的项目提案，可以从捐助者众筹资金。 旨在促进有意义的开源项目的开发，并更好的协调捐助者和开发者的利益。 社交DAO其旨在将志同道合的人聚集在同一网络社区中，围绕一种代币进行协调。 示例：FWB FWB它是一个将集体文化和技术结合在一起的新型社交社区，是一个自行组织，富有创造力的互联网原生社区。它以人类价值观为核心，成员共同进行内容创作。 它由艺术家、创作者和领导web3.0转型的人员组成，fwb是成员和实现集体使命的技术之间的桥梁。 工作流程 其有个参与框架 治理包含fwb代币持有者，他们投票支持dao的提案并通过论坛参与治理 董事会 董事会由团队成员、顾问和社区成员等混合实体组成，他们专注于制定有效的社区建设战略。 团队负责人 管理贡献者团队的成员，根据自己的经验被选出的。批准用于赏金或奖励的资金，设定关键优先事项以促进协助成功 贡献者 持有fwb的成员。贡献者通过积极参与活动为团队提供动力，并根据他们的贡献水平获得奖励。 APE旨在促进去中心化和推进由社区主导的治理模式，任务是管理apecoin dao的决策，负责日常行政、薄记、项目管理和其他任务，以确保dao社区的想法得到足够的支持，因为去中心化治理对于建立和管理一个全球分散的社区很重要。 服务DAO客户可以为特点任务发放奖金，一旦完成，它在奖励个人贡献者之前需要向dao金库支付部份费用。贡献者通常还会收到在dao中传达所有权的治理通行证。 出现背景 贡献者获得直接所有权 服务dao的贡献者既获得了他们为每个客户创作的价值的份额，也获得了整个组织的份额 开放的贡献文化 一些服务dao是结构化的，因此任何人都可以加入并做出贡献。过滤申请人都dao更看重一个人为dao增值的能力 更好的理解客户的问题 减少贡献者的收入波动 贡献者通过服务dao社区和客户的项目获得报酬，而项目中的报酬一部份为累计到组织中的所有利益相关者，个人贡献者可以随着时间的推移而平滑收益波动。","categories":["web3"]},{"title":"【Wasm】介绍(未完成)","path":"/2024/02/06/读书笔记/【Wasm】介绍----1/","content":"出现背景webAssembly的堆栈式结构被设计为编码为一种高密度，可以被浏览器快速加载和执行的二进制格式。 webAssembly的设计初衷是希望浏览器以近似原生C&#x2F;C++应用的运行速度，来调用Wasm模块中包含的这各类型平台（处理器架构）上都可以使用的通用硬件功能。 Wasm描述来一个内存安全的沙箱执行环境，可以在现有的js虚拟机中运行实现。当浏览器中运行一个Wasm模块时，Wasm将遵循浏览器中与Web应用一致的同源策略来保证其安全性。 基本原理Wasm主要是中v8解析js的解析器和编译链路中进行处理（Pipeline链路） 链路中各个编译器的前置Parser的语法分析，转换为AST中间数据格式 优化编译，TurboFn优化编译器会使用IC（Inline Cache）和OSR（On Stack Replacement）等对js源码进行分析和优化 进行lowering操作，优化编译器会根据现有的已经优化好的js源码来生成一些处于低层级且与硬件架构相关的中间代码。 此时加入Wasm操作 引擎不需要对Wasm模块中的二进制代码进行优化，也不需要生成冗余的占用大量内存的AST结构信息。只需要把这些模块中的二进制代码直接加载到内存中，然后经过位于V8链路末端编译器后端的处理，最后生成的机器码便可以直接被浏览器执行。 位于V8链路最末端的编译器后端（backend）负责将这些经过处理后的代码直接转译成基于特定处理器架构的机器码，最后再被浏览器解析和执行","categories":["webAssembly"]},{"title":"【vue】虚拟dom基本","path":"/2024/02/06/读书笔记/【vue】虚拟dom基本/","content":"原由在项目运行时，页面状态会不断变化，每当状态变化时，都需要重新渲染。如果每次都直接将页面全部替换更新，那么由于访问dom是相对昂贵的，这样会导致非常多的性能浪费。因此当某个状态变化时，只更新与这个状态相关联的dom节点。虚拟dom通过状态声称一个虚拟节点树，然后使用虚拟节点树进行渲染。在更新的时候，只需要比较上一次的节点树与当前节点树有何不同，更新不同的地方即可。 vnode类型注释节点 有效属性text和isComment 元素：1&lt;！—注释—&gt; vnode：1234&#123;text：”注释”，isComment：true&#125; 文本节点 有效属性text 创建过程 123function createTextVnode(val)&#123;return new VNode(undefined, undefined, undefined,String(val));&#125; 克隆属性 特殊属性isCloned 创建过程 1234567891011function createCloneVnode(vnode, deep)&#123;const cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory)cloned.ns = vnode.nscloned.isStatic = vnode.isStaticcloned.key = vnode.keycloned.isComment = vnode.isCommentcloned.isCloned = trueif(deep &amp;&amp; vnode.children)&#123;cloned.children = createCloneVnode(vnode.children)&#125;&#125; 元素节点 有效属性tag: 节点名称，例如div、li等data: 节点上的数据，例如attrs、class等children: 当前节点的子节点列表context: 当前组件的vuejs实例 元素： 1&lt;div&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt; vnode 123456&#123;children: [VNode, VNode]，context: &#123;…&#125;,data：&#123;…&#125;，tag: “div”&#125; 组件节点 特有属性：componentOptions: 组件节点的选项参数，包括propsData、tag、children等componentInstance: 组件实例 函数式组件 特有属性：functionContextfunctionOptions","categories":["vue"]},{"title":"【markdown】语法","path":"/2024/02/06/读书笔记/【markdown】语法/","content":"***、—、___可以显示横线效果 链接除了最基本的外，还包含以下 引用链接 link 网址链接 https:// 扩展语法GFM 删除线～ 删除 下划线 a 上标 这是^上标^ 下标 这是下标 表情 :smile: 表情地址 任务列表 list 1 list2 锚点 point 排版空格 中英文之间、中英文与数字之间、英文标点符号与后面的文字之间 其他语言转换工具Pandoc vs code语法增强插件markdown preview enhanced 语法 引用文件 1@import “文件名” 可以将文件内容直接显示，包括图片、csv表格 幻灯片 1234&lt;!— slide—&gt;First&lt;!— slide—&gt;Second 使用库：reveal.js 交互性工具交互性md工具可以直接执行代码 jupyter notebook r markdown 锚点其实呢，每一个标题都是一个锚点，和HTML的锚点（#）类似，比如我们 语法 效果 [回到顶部](#readme) 回到顶部 不过要注意，标题中的英文字母都被转化为小写字母了。 以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！ 复选框列表 需求分析 系统设计 详细设计 编码 测试 交付 您可以使用这个功能来标注某个项目各项任务的完成情况。 Tip: 在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。 块引用常用于引用文本文本摘自《深入理解计算机系统》P27　令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。 “端”（endian）的起源以下是Jonathan Swift在1726年关于大小端之争历史的描述：“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。” 块引用有多级结构 数据结构 树 二叉树 平衡二叉树 满二叉树 对齐表格可以指定对齐方式 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 表情Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。 比如:blush:，可以显示:blush:。 具体每一个表情的符号码，可以查询GitHub的官方网页http://www.emoji-cheat-sheet.com。 但是这个网页每次都打开奇慢。。所以我整理到了本repo中，大家可以直接在此查看emoji。 diff语法版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。 其语法与代码高亮类似，只是在三个反引号后面写diff，并且其内容中，以 + 开头表示新增，- 开头表示删除。 效果如下： 12+ 鸟宿池边树，僧敲月下门- 鸟宿池边树，僧推月下门","categories":["额外内容"]},{"title":"【js】属性描述符","path":"/2024/02/06/读书笔记/【js】属性描述符/","content":"object属性与方法 通过使用Object.getOwnPropertyDescriptor(object, name)来配置属性 wirteable 设置后无法修改属性值，严格模式下会报错 类似于设置了getter和setter，但是setter是个空操作的。 如果想用setter实现wirteable，那么需要在严格模式下进行报错 configurable 表明属性是否可以再进行配置以及是否禁止删除这个属性 123Object.getOwnPropertyDescriptor(object, name,&#123;configurable: false&#125;)//报错//Object.getOwnPropertyDescriptor(object, name,&#123;configurable: true&#125;) configureable:false时可以将wirteable从true改为false，但是不能从false改为true enumerable 是否出现在对象的枚举属性中，设置为false后，在for..in中就不会再出现这个属性 obj.propertyIsEnumerabel(key)检查该键是否存在对象(不检查原型链)中且enumerable为true，判断该键是否可枚举。 Object.preventExtensions(obj) 禁止一个对象添加新属性并且保留已有属性 Object.seal(obj) 不能添加新属性，也无法重新配置或者删除任何属性 实际上实际上是在一个现有对象上调用 Object.preventExtensions(obj) ，并且把所有现有属性标记为 configurable: false Object.freeze(obj) 禁止对对象本身及其任意属性的修改 实际上是在现有对象上调用 Object.seal，并且把所有属性标注为 . wirtable: true","categories":["js"]},{"title":"【js】this指向","path":"/2024/02/06/读书笔记/【js】this指向/","content":"this优先级 通过new进行创建的，this指向创建的对象 如果构造函数返回了一个对象，那么绑定的this就是返回对象的 如果构造函数没有返回对象，返回的是number或者boolean，那么实际返回的也是这个构造函数 显示绑定（bind&#x2F;apply）：如果传的是null或者undefined，实际应用的是默认绑定规则 隐式绑定，绑定的是那个的上下文对象123Var fn()&#123;&#125;Var obj = &#123;fun: fun&#125;Obj.fun();//指向的是obj 默认绑定，严格模式下是undefined，非严格模式下是全局对象 实例1234567const a=&#123; text:1,fn: function ()&#123;return this.text&#125;&#125;const b=&#123; text:1,fn: function ()&#123;const aa=a.fn;return aa();// 输出undefined，因为是在window层调用的&#125;&#125;","categories":["js"]},{"title":"【Htpp】header","path":"/2024/02/06/读书笔记/【Htpp】header/","content":"通用头部cache-control控制缓存，可以接收多个参数，参数之间以“，”隔空。 请求和响应共用 no-cache：表示强制使用最新的值而不使用缓存。请求头部包含no-cache，表示客户端不接收缓存过的响应，缓存服务器必须把客户端请求转发给源服务器；响应请求里面包含，那么缓存服务器不能对响应资源进行缓存。 no-store：不应该缓存当前内容，表示对应的报文中包含机密信息 no-transform：缓存不能改变主体的媒体类型，能防止缓存服务器压缩图片资源等。 max-age：缓存有效期（以秒为单位）。请求包含时，如果缓存资源的缓存时间比指定时间数值更小时则接受缓存资源，当值为0时，缓存服务器会把请求转发给源服务器；当响应包含时，缓存服务器不再确认资源的有效期，而以max-age数值作为缓存保存时长。 请求头部 min-fresh：要求缓存服务器指定时间内返回响应（以秒为单位） only-if-cached：客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回值，也就是说不会向源服务器转发请求。 响应头部 must-revalidate：本地缓存过期前可以使用，否则必须进行有效性校验 public：响应可能会被任何对象缓存，没有限制 private： 响应只能被特定用户缓存，不能被其他用户使用 proxy-revalidate：仅适用于共享缓存，私有缓存时忽略 connection close: 当一方的connection为close时，表示关闭此次连接 keep-live：持久化连接 date报文创建时间 请求头部accept可以设置多个值，每个值通过“，”进行分割 常用值：text&#x2F;html，application&#x2F;xml；q&#x3D;0.9等 注：q&#x3D;x，是给当前类型赋予权重，范围为0～1，可精确到小数点后3位。和MIME子类型通过“，”分割，默认权重值为1。服务器会优先返回权重较大的类型，如果权重相等，则按照从左至右的顺序处理。 accept-charset客户端可以处理的字符集类型，通常不需要额外设置此项，每种文件类型都有默认的值。和accept一样可以设置权重 accept-encoding客户端可以接收的编码方式，通常这个字段值会是某种压缩算法，比如gzip等。和accept一样可以设置权重 accept-language客户端可以解析的自然语言，可以一次性指定多个语言并设置权重。 authorization告知服务端认证信息。通常在收到401后，在请求头里面加入authorization：type credentials host（必传）告知服务器请求资源所处的互联网主机名和端口号（不指定将使用默认端口号）。 必传是因为服务器在接收到请求后将请求的主机号替换为ip地址，但是如果这个ip部署了多个域名，那么服务器无法转发到对应的请求 if-modified-since确认代理或者客户端本地资源的有效性。服务端在接受到这个值后，会与资源最近更新时间做对比，如果在字段指定的日期之后资源发生了变化，那么服务器会返回最新的资源，否则返回304 if-none-match用于判断本地缓存是否失效。存储的是上个响应头部的etag值。当指定的值与资源的etag值不一致时，服务器端才会处理请求 响应头部age告知客户端服务端在多久前创建了响应，若创建该响应的是缓存服务器，age指的是缓存后响应再次发起认证到认证完成的时间。代理创建响应必须加上age字段 etag服务端在每次更新资源后生成一个唯一对应的标识，生成算法由服务器自行决定 分类： 强etag：资源发生变化就会改变 弱etag：资源发生了较大变化时才会改变。以W&#x2F;来表示 location使用头部字段location可以引导请求发起方至某个与请求url位置不同的资源，一般会配合3xx进行使用 www-authenticate告知客户端当前服务器端可接收的认证方案，然后客户端可以在authentication字段中返回对应的值 主体头部allow通知客户端能够支持的http请求方法。当服务端接收到不支持http请求方法时，会响应状态信息405，同时把支持的方法写入allow字段 content-encoding告知客户端当前响应内容的编码方式 content-length表明主体部分的大小，单位为字节 content-type表明响应主体内容的MIME类型 last-modified资源最后的修改时间，配合缓存使用 expires失效日期","categories":["http"]},{"title":"【css】流向修改","path":"/2024/02/06/读书笔记/【css】流向修改/","content":"direction值 ltr 默认值，从左到右 rtl 从右到左 场景 文字省略号转向，且不影响文字的流向 表格呈现顺序 unicode-bidi属性值 normal 默认值，元素正常排列。但若设置了direction：rtl，则图片、按钮和问号、加号之类的字符会从右往左显示，但中英文还是从左往右 embed 其只能作用于内联元素。其会开启一个看不见的嵌入层，然后自己在里面重新排序，所以不会受到外部unicode-bidi影响 其和在元素前嵌入U+202B和后嵌入U+202C效果一致 bidi-override 重写双向排序规则，通常样式表现为所有字符都按照统一的direction顺序排序 其和在元素前嵌入U+202E和后嵌入U+202C效果一致 wirting-mode属性css3语法 horizontal-tb 文本流为水平方向，元素从上往下堆叠 vertical-rl 垂直方向，从右往左堆叠，和古诗词顺序一致 vertical-lr 垂直方向，从左往右堆叠 inherit initial unset ie lr-tb ie7以上支持，从左往右，从上往下，且下一行水平元素在上一行元素的下面 rl-tb ie7+，从右往左，从上往下，且下一行水平元素在上一行元素的下面 tb-rl ie7+，从下往上，从右往左，下一个垂直行定位于前一个垂直行的左边 bt-rl ie7+，从下往上，从右到左，下一个垂直行定位于前一个垂直行的左边 tb-lr ie8+，从上往下，从左往右垂直 bt-lr ie8+，从下往上，从左往右垂直 lr-bt ie8+，从下往上，从右往左水平 rl-bt ie8+，从下往上，右往左水平 lr ie9+，svg和html上使用，等同于lr-tb rl ie9+，svg和html上使用，等同于rl-tb tb ie9+，svg和html上使用，等同于tb-rl 改变内容 margin margin重叠可以在垂直和水平方向上都会进行 margin：auto 可以实现垂直居中 text-align：center 图片垂直居中 text-indent 可以用这个属性实现文字往下一沉的效果 iconfonts旋转","categories":["css"]},{"title":"【css】属性关键字","path":"/2024/02/06/读书笔记/【css】属性关键字/","content":"inherit继承，从IE8开始支持 initial初始值关键字，把当前css属性的计算值还原为css语法中规定的初始值 注：并不是将其还原为浏览器默认的初始值 unset如果当前使用的css属性是具有继承特性的，例如color，那么就和inherit表现一致 如果当时使用的css属性没有继承特性，那么就表现和initial一致 revert当前元素还原为浏览器内置的样式 allall属性可以重置除unicode-bidi、direction以及css自定义属性外的所有css属性。 1all：initial ｜inherit ｜unset｜revert fit-content用子元素的宽高来确定当前元素的数据。 min-content最小内容宽度或首选最小宽度 替换元素min-content手当前元素内容自身的宽度。 CJK文字如果是没有标点的中文，那么min-content是单个汉字的宽度 如果是包含避头标点（，。？、！等）或者避尾标点（“（等），且line-break不是anywhere的中文，那么min-content是包含标点字符的宽度 非GJK文字min-content是由字符单元的宽度决定的，所有连续的英文字母、数字和标点都被认为是一个字符单元，直到遇到中断字符 最终的首选最小宽度是所有内部子元素中最大的那个首选最小宽度值 max-content最大内容宽度 stretch、available、fill-available都是让元素尺寸自动填满可用空间 stretch 弹性拉伸，替换之前的fill- available和available available 可用空间，firefox的关键字，需加上-moz-前缀 fill-avaiable 填充可用空间，需配合-webkit-私有前缀","categories":["css"]},{"title":"【css】取值规则","path":"/2024/02/06/读书笔记/【css】取值规则/","content":"作用css本质上就是声明规则，在各种条件下，产生特定的效果。因此层叠（cascade）决定了如何解决冲突，是css语言的基础 规则当样式发生冲突，层叠会依据三种条件解决冲突 样式表来源样式来自哪儿，自己设定的样式和浏览器默认的样式等 用户代理样式 即浏览器默认样式，浏览器应用了用户代理样式之后才会应用作者样式表，后者会覆盖前者的样式 !important 重要声明，标记了的样式会被当作更高优先级的来源 选择器优先级哪些选择器比另一些选择器更重要，浏览器的优先级被分为两个部分：html的行内样式和选择器的样式 准确规则：id选择器数量&gt;id选择器数量一致，类多的选择器&gt;标签名多的选择器多 源码顺序样式在样式表里的声明顺序 inherit和initialinherit继承父级的值 initial撤销设定的样式属性，回归到这个属性的初始值","categories":["css"]},{"title":"consoleAPI","path":"/2024/02/06/读书笔记/【console】API/","content":"assert参数1console.assert(boolean, …args) 输出但第一个参数为false时进行输出 count参数123console.count(args)console.countReset(args) // 归零累计值 输出累计特定标签出现的次数 group使用1234567console.group(“start”)console.log(“info”)console.groupCollapsed(“child”)console.log(“data”)console.groupEnd()console.log(“data2”)console.groupEnd() 作用让输出信息更加显眼聚合，易于查看 table使用1console.table(rows,[key1,key2] 作用以表格打印对象内容，一次性显示更多信息 time使用12console.time(args)console.timeEnd(args) 作用测量时间 trace使用1console.trace() 作用打印当前的call stack monitor使用12345function fn(…args)&#123;….&#125;monitor(fn)fn(“data”, “data2”) 作用执行该函数时，输出参数。但是无法执打印箭头函数的参数 monitorEvents使用1monitorEvents(window, “click”) 作用监听并打印元素触发的事件 getEventListeners使用1getEventListeners(el) 作用打印所有注册在元素上的事件监听器 queryObjects使用1queryObjects(obj) 作用打印所有原型链中包含该原型的对象","tags":["console","chrome","js"],"categories":["js"]},{"title":"docker","path":"/2024/02/06/读书笔记/docker/","content":"作用一种虚拟化的技术。 解决因为依赖而导致各种各样的问题 虚拟机可以对运行环境进行封装和隔离，但虚拟机消耗空闲的磁盘，内存等硬件资源，且不利于快速部署和扩展 docker具有与虚拟机同样的优点(容器内部与外部的环境是隔离的，每个容器内部配置的资源不会影响到其他容器，跨平台)，还可以节省资源，生成镜像快速部署和启停，具有强大的编排工具可以批量跨机器操作容器等。 存储直接存在容器中缺点： 数据无法持久化。当容器无法再启动时，那么里面的数据就无法再进行读取。 数据隔离，容器的数据无法与其他容器或者主机进行共享 写入速度慢，容器写入的数据会被转化为联合文件系统格式，不如直接写入主机的速度快 docker提供了三种挂载数据的方式：存储卷，绑定挂载，tmpfs挂载 绑定挂载直接让容器和主机共享目录和文件，可能在主机任何位置被进行存储，或者被任意进程进行修改。 使用场景 配置文件 开发环境中的源代码或者编译后的代码 其他一些特殊的文件或者目录结构 tmpfs挂载只存储于主机的内容，不存储于主机的文件系统中 使用场景 安全原因：不想数据持久化也不想存储于容器中，需要适应后立即删除 性能原因：大数据快速读写 存储卷(推荐通过docker创建一个卷，并以文件的形式存储于主机磁盘中，非docker进程无法修改这个文件 好处： 相比绑定挂载，数据更加容易迁移和备份 可以通过docker命令或者docker api进行管理 在Linux和window主机都可以使用 跨容器共享数据更加安全 允许存储到远程主机或者云设备，允许对数据进行加密或执行其他高级功能 新的卷能被容器内的文件预填充 使用场景 多容器共享数据。当容器需要的卷不存在时，会创建一个新的卷。卷不会随着容器的消失而消失，需要手动删除，还可以设置其只读&#x2F;只读写属性 主机无法提供给定的目录或者文件结构时，卷能解耦主机和容器的运行环境 数据需要被存储于云设备或者远程主机而不仅仅是本地时 数据需要从一台主机上的容器备份&#x2F;恢复&#x2F;迁移到另一台主机上的容器时。","categories":["额外内容"]},{"title":"Hello World","path":"/2024/02/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"【css】不常用属性总结","path":"/2023/07/28/【css】不常用属性总结/","content":"【css】、不常用样式总结关于文字换行 word-break 换行规则 white-space 保留换行和空格 word-wrap(老) &#x2F; overflow-wrap(新) line-break hyphens 用于英文字符 有机会就断开换行 直接换行 背景 background-size background-image 可以设置多背景 background-clip 控制背景显示区域，还可以设置文字的渐变色 background-origin 背景定位原点 background-repeat 背景图片重复设置 background-position 叠加属性即父组件和子组件 同时设置一个属性，其表现并非是子组件覆盖父组件或者父组件覆盖子组件，而是将其两个属性值进行叠加计算 opacity 用乘法计算出的结果 text-decoration 会两个都进行显示","categories":["css"]}]